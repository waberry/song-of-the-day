{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/env.js"],"sourcesContent":["import { createEnv } from \"@t3-oss/env-nextjs\";\nimport { z } from \"zod\";\n\nexport const env = createEnv({\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars.\n   */\n  server: {\n    DATABASE_URL: z.string().url(),\n    NODE_ENV: z\n      .enum([\"development\", \"test\", \"production\"])\n      .default(\"development\"),\n  },\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars. To expose them to the client, prefix them with\n   * `NEXT_PUBLIC_`.\n   */\n  client: {\n    // NEXT_PUBLIC_CLIENTVAR: z.string(),\n  },\n\n  /**\n   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.\n   * middlewares) or client-side so we need to destruct manually.\n   */\n  runtimeEnv: {\n    DATABASE_URL: process.env.DATABASE_URL,\n    NODE_ENV: process.env.NODE_ENV,\n    // NEXT_PUBLIC_CLIENTVAR: process.env.NEXT_PUBLIC_CLIENTVAR,\n  },\n  /**\n   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially\n   * useful for Docker builds.\n   */\n  skipValidation: !!process.env.SKIP_ENV_VALIDATION,\n  /**\n   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and\n   * `SOME_VAR=''` will throw an error.\n   */\n  emptyStringAsUndefined: true,\n});\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,MAAM,MAAM,CAAA,GAAA,+JAAA,CAAA,YAAS,AAAD,EAAE;IAC3B;;;GAGC,GACD,QAAQ;QACN,cAAc,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG;QAC5B,UAAU,sIAAA,CAAA,IAAC,CACR,IAAI,CAAC;YAAC;YAAe;YAAQ;SAAa,EAC1C,OAAO,CAAC;IACb;IAEA;;;;GAIC,GACD,QAAQ;IAER;IAEA;;;GAGC,GACD,YAAY;QACV,cAAc,QAAQ,GAAG,CAAC,YAAY;QACtC,QAAQ;IAEV;IACA;;;GAGC,GACD,gBAAgB,CAAC,CAAC,QAAQ,GAAG,CAAC,mBAAmB;IACjD;;;GAGC,GACD,wBAAwB;AAC1B"}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 102, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/server/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nimport { env } from \"~/env\";\n\nconst createPrismaClient = () =>\n  new PrismaClient({\n    log:\n      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: ReturnType<typeof createPrismaClient> | undefined;\n};\n\nexport const db = globalForPrisma.prisma ?? createPrismaClient();\n\nif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = db;\n"],"names":[],"mappings":";;;AAAA;AAEA;;;AAEA,MAAM,qBAAqB,IACzB,IAAI,2GAAA,CAAA,eAAY,CAAC;QACf,KACE,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,gBAAgB;YAAC;YAAS;YAAS;SAAO,GAAG;YAAC;SAAQ;IAC3E;AAEF,MAAM,kBAAkB;AAIjB,MAAM,KAAK,gBAAgB,MAAM,IAAI;AAE5C,IAAI,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,cAAc,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 127, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/server/api/trpc.ts"],"sourcesContent":["/**\n * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n * 1. You want to modify request context (see Part 1).\n * 2. You want to create a new middleware or type of procedure (see Part 3).\n *\n * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n * need to use are documented accordingly near the end.\n */\nimport { initTRPC } from \"@trpc/server\";\nimport superjson from \"superjson\";\nimport { ZodError } from \"zod\";\n\nimport { db } from \"~/server/db\";\n\n/**\n * 1. CONTEXT\n *\n * This section defines the \"contexts\" that are available in the backend API.\n *\n * These allow you to access things when processing a request, like the database, the session, etc.\n *\n * This helper generates the \"internals\" for a tRPC context. The API handler and RSC clients each\n * wrap this and provides the required context.\n *\n * @see https://trpc.io/docs/server/context\n */\nexport const createTRPCContext = async (opts: { headers: Headers }) => {\n  return {\n    db,\n    ...opts,\n  };\n};\n\n/**\n * 2. INITIALIZATION\n *\n * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\n * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\n * errors on the backend.\n */\nconst t = initTRPC.context<typeof createTRPCContext>().create({\n  transformer: superjson,\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\n/**\n * Create a server-side caller.\n *\n * @see https://trpc.io/docs/server/server-side-calls\n */\nexport const createCallerFactory = t.createCallerFactory;\n\n/**\n * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n *\n * These are the pieces you use to build your tRPC API. You should import these a lot in the\n * \"/src/server/api/routers\" directory.\n */\n\n/**\n * This is how you create new routers and sub-routers in your tRPC API.\n *\n * @see https://trpc.io/docs/router\n */\nexport const createTRPCRouter = t.router;\n\n/**\n * Middleware for timing procedure execution and adding an artificial delay in development.\n *\n * You can remove this if you don't like it, but it can help catch unwanted waterfalls by simulating\n * network latency that would occur in production but not in local development.\n */\nconst timingMiddleware = t.middleware(async ({ next, path }) => {\n  const start = Date.now();\n\n  if (t._config.isDev) {\n    // artificial delay in dev\n    const waitMs = Math.floor(Math.random() * 400) + 100;\n    await new Promise((resolve) => setTimeout(resolve, waitMs));\n  }\n\n  const result = await next();\n\n  const end = Date.now();\n  console.log(`[TRPC] ${path} took ${end - start}ms to execute`);\n\n  return result;\n});\n\n/**\n * Public (unauthenticated) procedure\n *\n * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n * guarantee that a user querying is authorized, but you can still access user session data if they\n * are logged in.\n */\nexport const publicProcedure = t.procedure.use(timingMiddleware);\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;;;;AACD;AACA;AAGA;AAJA;AAEA;;;;;AAgBO,MAAM,oBAAoB,OAAO;IACtC,OAAO;QACL,IAAA,qHAAA,CAAA,KAAE;QACF,GAAG,IAAI;IACT;AACF;AAEA;;;;;;CAMC,GACD,MAAM,IAAI,kMAAA,CAAA,WAAQ,CAAC,OAAO,GAA6B,MAAM,CAAC;IAC5D,aAAa,4IAAA,CAAA,UAAS;IACtB,gBAAe,EAAE,KAAK,EAAE,KAAK,EAAE;QAC7B,OAAO;YACL,GAAG,KAAK;YACR,MAAM;gBACJ,GAAG,MAAM,IAAI;gBACb,UACE,MAAM,KAAK,YAAY,sIAAA,CAAA,WAAQ,GAAG,MAAM,KAAK,CAAC,OAAO,KAAK;YAC9D;QACF;IACF;AACF;AAOO,MAAM,sBAAsB,EAAE,mBAAmB;AAcjD,MAAM,mBAAmB,EAAE,MAAM;AAExC;;;;;CAKC,GACD,MAAM,mBAAmB,EAAE,UAAU,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE;IACzD,MAAM,QAAQ,KAAK,GAAG;IAEtB,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE;QACnB,0BAA0B;QAC1B,MAAM,SAAS,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,OAAO;QACjD,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS;IACrD;IAEA,MAAM,SAAS,MAAM;IAErB,MAAM,MAAM,KAAK,GAAG;IACpB,QAAQ,GAAG,CAAC,CAAC,OAAO,EAAE,KAAK,MAAM,EAAE,MAAM,MAAM,aAAa,CAAC;IAE7D,OAAO;AACT;AASO,MAAM,kBAAkB,EAAE,SAAS,CAAC,GAAG,CAAC"}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 199, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/utils.ts"],"sourcesContent":["export function getRandom64BitNumber() {\n    // Generate two 32-bit random numbers using Math.random()\n    const high = Math.floor(Math.random() * 0xFFFFFFFF); // Upper 32 bits\n    const low = Math.floor(Math.random() * 0xFFFFFFFF);  // Lower 32 bits\n  \n    // Combine high and low to create a 64-bit number\n    const random64BitNumber = (BigInt(high) << 32n) | BigInt(low);\n  \n    return random64BitNumber;\n  }"],"names":[],"mappings":";;;AAAO,SAAS;IACZ,yDAAyD;IACzD,MAAM,OAAO,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,aAAa,gBAAgB;IACrE,MAAM,MAAM,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,aAAc,gBAAgB;IAErE,iDAAiD;IACjD,MAAM,oBAAoB,AAAC,OAAO,SAAS,GAAG,GAAI,OAAO;IAEzD,OAAO;AACT"}},
    {"offset": {"line": 210, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 216, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/server/api/routers/song.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nimport { z } from \"zod\";\n\nimport { createTRPCRouter, publicProcedure } from \"~/server/api/trpc\";\nimport { getRandom64BitNumber } from \"~/utils\";\n\nconst prisma = new PrismaClient();\n\n// To put in the Guess Service Layer\nenum Comparison {\n  Smaller = -1,\n  Equal = 0,\n  Bigger = 1\n}\n\n\nexport const songRouter = createTRPCRouter({\n  getSongToGuess: publicProcedure\n    .input(\n      z.object({\n        anonymousUserId: z.string(),\n        modeId: z.number(),\n      })\n    ).query(async ({ input }) => {\n    console.log('Validated input:', input); // Zod validates the input here\n    console.log(\"coucou2\")\n\n    // Check if the mode exists in the mode table\n    const mode = await prisma.mode.findUnique({\n      where: { id: input.modeId },\n    });\n\n    if (!mode) {\n      throw new Error('Invalid mode');\n    }\n\n    // Check if the user exists\n    let user = await prisma.user.findUnique({\n      where: { anonymousUserId: input.anonymousUserId },\n    });\n\n    // If the user doesn't exist, create a new one\n    if (!user) {\n      user = await prisma.user.create({\n        data: {\n          anonymousUserId: input.anonymousUserId,\n        },\n      });\n    }\n\n    // Get today's date range\n    const today = new Date();\n    const startOfDay = new Date(today.setHours(0, 0, 0, 0));\n    const endOfDay = new Date(today.setHours(23, 59, 59, 999));\n\n    // Check if there's already an entry in the \"day\" table for today\n    let dayEntry = await prisma.day.findFirst({\n      where: {\n        date: {\n          gte: startOfDay,\n          lte: endOfDay,\n        },\n      },\n    });\n\n\n    const response = {\n      mode: mode, \n      dayEntry: dayEntry\n    }\n\n    // If no entry exists, create a new one for today\n    if (!dayEntry) {\n      console.log(\"dayEntry doesnt exist yet\")\n      dayEntry = await prisma.day.create({\n        data: {\n          date: new Date(),\n          seed: getRandom64BitNumber().toString(),\n        },\n      });\n    }\n\n    console.log(\"returned \",response)\n\n    return response\n\n\n    // // Count successful guesses for today\n    // let todaysUserGuesses = await prisma.guess.count({\n    //   where: {\n    //     userId: user.id,\n    //     date: {\n    //       gte: startOfDay,\n    //       lte: endOfDay,\n    //     },\n    //   },\n    // });\n\n    // // Get Spotify song IDs from the playlist\n    // const songsIDs = await getSpotifyPlaylistTracks(mode.playlistId);\n    // const todaysIndexSequence = ShuffleIndexes(dayEntry.seed, songsIDs.length);\n    // const songToGuessSpotifyId = songsIDs[todaysIndexSequence[todaysUserGuesses] ?? 0];\n\n    // // Compare the song to guess with the provided song ID\n    // const detailedComparison = await compareSongs(songToGuessSpotifyId, songSpotifyId);\n   \n    // Static comparison for now, we need to compute the comparison correctly when we add the spotify and brainz services\n    let detailedComparison = {\n      artists: [{name: \"Kanye West\", success: true}, {name: \"Chance The Rapper\", success: false}],\n      albumName: false,\n      duration: Comparison.Bigger,\n      years: Comparison.Smaller,\n      decades: Comparison.Smaller,\n      genres: [{name: \"rap\", success: true}, {name: \"pop\", success: false}],\n      popularity: Comparison.Bigger,\n      countries: [{name: \"USA\", success: true}, {name: \"China\", success: false}]\n    }\n    \n    // Store the guess in the database\n    const guess = await prisma.guess.create({\n      data: {\n        userId: user.id,\n        date: new Date(),\n        modeId: mode.id,\n        songSpotifyId: input.songSpotifyId,\n        success: true,\n        diff: detailedComparison,\n      },\n    });\n    return response\n\n    // return guess;\n  }),\n});\n"],"names":[],"mappings":";;;AAAA;AAGA;AACA;AAHA;;;;;AAKA,MAAM,SAAS,IAAI,2GAAA,CAAA,eAAY;AAE/B,oCAAoC;AACpC,IAAA,AAAK,oCAAA;;;;WAAA;EAAA;AAOE,MAAM,aAAa,CAAA,GAAA,8HAAA,CAAA,mBAAgB,AAAD,EAAE;IACzC,gBAAgB,8HAAA,CAAA,kBAAe,CAC5B,KAAK,CACJ,sIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACP,iBAAiB,sIAAA,CAAA,IAAC,CAAC,MAAM;QACzB,QAAQ,sIAAA,CAAA,IAAC,CAAC,MAAM;IAClB,IACA,KAAK,CAAC,OAAO,EAAE,KAAK,EAAE;QACxB,QAAQ,GAAG,CAAC,oBAAoB,QAAQ,+BAA+B;QACvE,QAAQ,GAAG,CAAC;QAEZ,6CAA6C;QAC7C,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;YACxC,OAAO;gBAAE,IAAI,MAAM,MAAM;YAAC;QAC5B;QAEA,IAAI,CAAC,MAAM;YACT,MAAM,IAAI,MAAM;QAClB;QAEA,2BAA2B;QAC3B,IAAI,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;YACtC,OAAO;gBAAE,iBAAiB,MAAM,eAAe;YAAC;QAClD;QAEA,8CAA8C;QAC9C,IAAI,CAAC,MAAM;YACT,OAAO,MAAM,OAAO,IAAI,CAAC,MAAM,CAAC;gBAC9B,MAAM;oBACJ,iBAAiB,MAAM,eAAe;gBACxC;YACF;QACF;QAEA,yBAAyB;QACzB,MAAM,QAAQ,IAAI;QAClB,MAAM,aAAa,IAAI,KAAK,MAAM,QAAQ,CAAC,GAAG,GAAG,GAAG;QACpD,MAAM,WAAW,IAAI,KAAK,MAAM,QAAQ,CAAC,IAAI,IAAI,IAAI;QAErD,iEAAiE;QACjE,IAAI,WAAW,MAAM,OAAO,GAAG,CAAC,SAAS,CAAC;YACxC,OAAO;gBACL,MAAM;oBACJ,KAAK;oBACL,KAAK;gBACP;YACF;QACF;QAGA,MAAM,WAAW;YACf,MAAM;YACN,UAAU;QACZ;QAEA,iDAAiD;QACjD,IAAI,CAAC,UAAU;YACb,QAAQ,GAAG,CAAC;YACZ,WAAW,MAAM,OAAO,GAAG,CAAC,MAAM,CAAC;gBACjC,MAAM;oBACJ,MAAM,IAAI;oBACV,MAAM,CAAA,GAAA,8GAAA,CAAA,uBAAoB,AAAD,IAAI,QAAQ;gBACvC;YACF;QACF;QAEA,QAAQ,GAAG,CAAC,aAAY;QAExB,OAAO;;QAGP,wCAAwC;QACxC,qDAAqD;QACrD,aAAa;QACb,uBAAuB;QACvB,cAAc;QACd,yBAAyB;QACzB,uBAAuB;QACvB,SAAS;QACT,OAAO;QACP,MAAM;QAEN,4CAA4C;QAC5C,oEAAoE;QACpE,8EAA8E;QAC9E,sFAAsF;QAEtF,yDAAyD;QACzD,sFAAsF;QAEtF,qHAAqH;QACrH,IAAI;QAWJ,kCAAkC;QAClC,MAAM;IAYN,gBAAgB;IAClB;AACF"}},
    {"offset": {"line": 318, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 324, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/server/api/routers/modes.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nimport { randomInt } from \"crypto\";\nimport { create } from \"domain\";\nimport { z } from \"zod\";\n\nimport { createTRPCRouter, publicProcedure } from \"~/server/api/trpc\";\n\nconst prisma = new PrismaClient();\n\nexport const modeRouter = createTRPCRouter({\n  getModes: publicProcedure\n  .query(async () => {\n    return await prisma.mode.findMany();\n  }),\n  createMode: publicProcedure\n  .input(\n    z.object({\n      playlistId: z.string(),\n    })\n  ).mutation(async ({ input }) => {\n    console.log('Validated input:', input); // Zod validates the input here\n\n    const { playlistId } = input;\n\n    const mode = await prisma.mode.create({\n      data: {\n        playlistId: playlistId,\n        name: \"New mode\",\n      },\n    });\n\n    return mode;\n  })\n});\n"],"names":[],"mappings":";;;AAAA;AAKA;AAFA;;;;AAIA,MAAM,SAAS,IAAI,2GAAA,CAAA,eAAY;AAExB,MAAM,aAAa,CAAA,GAAA,8HAAA,CAAA,mBAAgB,AAAD,EAAE;IACzC,UAAU,8HAAA,CAAA,kBAAe,CACxB,KAAK,CAAC;QACL,OAAO,MAAM,OAAO,IAAI,CAAC,QAAQ;IACnC;IACA,YAAY,8HAAA,CAAA,kBAAe,CAC1B,KAAK,CACJ,sIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACP,YAAY,sIAAA,CAAA,IAAC,CAAC,MAAM;IACtB,IACA,QAAQ,CAAC,OAAO,EAAE,KAAK,EAAE;QACzB,QAAQ,GAAG,CAAC,oBAAoB,QAAQ,+BAA+B;QAEvE,MAAM,EAAE,UAAU,EAAE,GAAG;QAEvB,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,MAAM,CAAC;YACpC,MAAM;gBACJ,YAAY;gBACZ,MAAM;YACR;QACF;QAEA,OAAO;IACT;AACF"}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 358, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/server/api/routers/player/old_player.ts"],"sourcesContent":["import { z } from 'zod';\nimport { createTRPCRouter as router, publicProcedure } from '~/server/api/trpc';\nimport { PrismaClient } from '@prisma/client';\nimport { TRPCError } from '@trpc/server';\n\nconst prisma = new PrismaClient();\n\n// Input validation schemas\nconst userIdentificationSchema = z.object({\n  fingerprint: z.string(),\n  userAgent: z.string(),\n  browser: z.string(),\n  browserVersion: z.string(),\n  os: z.string(),\n  osVersion: z.string(),\n  screenResolution: z.string(),\n  timezone: z.string(),\n});\n\nconst fingerprintSchema = z.object({\n  userAgent: z.string(),\n  browser: z.string(),\n  browserVersion: z.string(),\n  os: z.string(),\n  osVersion: z.string(),\n  screenResolution: z.string(),\n  timezone: z.string(),\n  fingerprint: z.string(),\n});\n\nexport const playerRouter = router({\n  hello: publicProcedure\n  .input(z.object({ text: z.string().min(1) }))\n  .query(async ({ input }) => {\n    return \"YOOO\";\n  }),\n  get: publicProcedure\n    .input(z.object({\n      anonymousUserId: z.string(),\n    }))\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Find user by anonymousUserId\n        const user = await prisma.user.findUnique({\n          where: {\n            anonymousUserId: input.anonymousUserId,\n          },\n          include: {\n            guesses: {\n              include: {\n                mode: true,\n              },\n            },\n          },\n        });\n\n        if (!user) {\n          throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: 'User not found',\n          });\n        }\n\n        // Get today's date range\n        const today = new Date();\n        const startOfDay = new Date(today.setHours(0, 0, 0, 0));\n        const endOfDay = new Date(today.setHours(23, 59, 59, 999));\n\n        // Get today's guesses\n        const todayGuesses = user.guesses.filter(guess => \n          guess.date >= startOfDay && guess.date <= endOfDay\n        );\n\n        // Calculate daily streak per mode\n        const dailyStreak = todayGuesses.reduce<Record<string, typeof todayGuesses>>((streak, guess) => {\n          const mode = guess.mode.name;\n          if (!streak[mode]) {\n            streak[mode] = [];\n          }\n          if (guess.success) {\n            streak[mode].push(guess);\n          }\n          return streak;\n        }, {});\n\n        // Calculate max streak per mode\n        const maxStreak = await prisma.guess.groupBy({\n          by: ['modeId'],\n          where: {\n            userId: user.id,\n            success: true,\n          },\n          _count: {\n            _all: true,\n          },\n        });\n\n        // Calculate current streak\n        const currentStreak = calculateCurrentStreak(user.guesses);\n\n        return {\n          todayGuesses,\n          dailyStreak,\n          maxStreak: maxStreak.reduce<Record<string, number>>((acc, item) => {\n            acc[item.modeId] = item._count._all;\n            return acc;\n          }, {}),\n          currentStreak,\n        };\n      } catch (error) {\n        if (error instanceof TRPCError) throw error;\n        throw new TRPCError({\n          code: 'INTERNAL_SERVER_ERROR',\n          message: 'An error occurred while processing the user data',\n          cause: error,\n        });\n      }\n    }),\n\n  submitGuess: publicProcedure\n    .input(z.object({\n      anonymousUserId: z.string(),\n      modeId: z.number(),\n      songSpotifyId: z.string(),\n      success: z.boolean(),\n      diff: z.record(z.any()),\n    }))\n    .mutation(async ({ input }) => {\n      try {\n        const user = await prisma.user.findUnique({\n          where: { anonymousUserId: input.anonymousUserId },\n        });\n\n        if (!user) {\n          throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: 'User not found',\n          });\n        }\n\n        const guess = await prisma.guess.create({\n          data: {\n            userId: user.id,\n            modeId: input.modeId,\n            songSpotifyId: input.songSpotifyId,\n            success: input.success,\n            diff: input.diff,\n          },\n          include: {\n            mode: true,\n          },\n        });\n\n        return guess;\n      } catch (error) {\n        throw new TRPCError({\n          code: 'INTERNAL_SERVER_ERROR',\n          message: 'Failed to submit guess',\n          cause: error,\n        });\n      }\n    }),\n\n  getStats: publicProcedure\n    .input(z.object({\n      anonymousUserId: z.string(),\n      modeId: z.number().optional(),\n    }))\n    .query(async ({ input }) => {\n      try {\n        const user = await prisma.user.findUnique({\n          where: { anonymousUserId: input.anonymousUserId },\n        });\n\n        if (!user) {\n          throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: 'User not found',\n          });\n        }\n\n        const whereClause = {\n          userId: user.id,\n          ...(input.modeId ? { modeId: input.modeId } : {}),\n        };\n\n        const stats = await prisma.guess.groupBy({\n          by: ['modeId'],\n          where: whereClause,\n          _count: {\n            _all: true,\n            success: true,\n          },\n        });\n\n        return stats;\n      } catch (error) {\n        throw new TRPCError({\n          code: 'INTERNAL_SERVER_ERROR',\n          message: 'Failed to fetch stats',\n          cause: error,\n        });\n      }\n    }),\n\n  identify: publicProcedure\n    .input(fingerprintSchema)\n    .mutation(async ({ input, ctx }) => {\n      const existingUser = await ctx.db.user.findUnique({\n        where: { anonymousUserId: input.fingerprint }\n      });\n\n      if (existingUser) {\n        return {\n          anonymousUserId: existingUser.anonymousUserId,\n          isNewUser: false\n        };\n      }\n\n      const newUser = await ctx.db.user.create({\n        data: {\n          anonymousUserId: input.fingerprint\n        }\n      });\n\n      return {\n        anonymousUserId: newUser.anonymousUserId,\n        isNewUser: true\n      };\n    }),\n});\n// Helper function to calculate current streak\nfunction calculateCurrentStreak(guesses: any[]): number {\n  const sortedGuesses = [...guesses].sort((a, b) => \n    new Date(b.date).getTime() - new Date(a.date).getTime()\n  );\n  \n  let streak = 0;\n  for (const guess of sortedGuesses) {\n    if (guess.success) {\n      streak++;\n    } else {\n      break;\n    }\n  }\n  return streak;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 590, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 596, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/server/api/root.ts"],"sourcesContent":["import { createCallerFactory, createTRPCRouter } from \"~/server/api/trpc\";\nimport { songRouter } from \"./routers/song\";\nimport { modeRouter } from \"./routers/modes\";\nimport { playerRouter } from \"./routers/player/old_player\";\n\n/**\n * This is the primary router for your server.\n *\n * All routers added in /api/routers should be manually added here.\n */\nexport const appRouter = createTRPCRouter({\n  mode: modeRouter,\n  song: songRouter,\n  player: playerRouter,\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n\n/**\n * Create a server-side caller for the tRPC API.\n */\nexport const createCaller = createCallerFactory(appRouter);\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAOO,MAAM,YAAY,CAAA,GAAA,8HAAA,CAAA,mBAAgB,AAAD,EAAE;IACxC,MAAM,0IAAA,CAAA,aAAU;IAChB,MAAM,yIAAA,CAAA,aAAU;IAChB,QAAQ,yJAAA,CAAA,eAAY;AACtB;AAQO,MAAM,eAAe,CAAA,GAAA,8HAAA,CAAA,sBAAmB,AAAD,EAAE"}},
    {"offset": {"line": 614, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 620, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/app/api/trpc/%5Btrpc%5D/route.ts"],"sourcesContent":["import { fetchRequestHandler } from \"@trpc/server/adapters/fetch\";\nimport { type NextRequest } from \"next/server\";\n\nimport { env } from \"~/env\";\nimport { appRouter } from \"~/server/api/root\";\nimport { createTRPCContext } from \"~/server/api/trpc\";\n\n/**\n * This wraps the `createTRPCContext` helper and provides the required context for the tRPC API when\n * handling a HTTP request (e.g. when you make requests from Client Components).\n */\nconst createContext = async (req: NextRequest) => {\n  return createTRPCContext({\n    headers: req.headers,\n  });\n};\n\nconst handler = (req: NextRequest) =>\n  fetchRequestHandler({\n    endpoint: \"/api/trpc\",\n    req,\n    router: appRouter,\n    createContext: () => createContext(req),\n    onError:\n      env.NODE_ENV === \"development\"\n        ? ({ path, error }) => {\n            console.error(\n              `‚ùå tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`\n            );\n          }\n        : undefined,\n  });\n\nexport { handler as GET, handler as POST };\n"],"names":[],"mappings":";;;;AAAA;AAGA;AACA;AACA;AALA;;;;;AAOA;;;CAGC,GACD,MAAM,gBAAgB,OAAO;IAC3B,OAAO,CAAA,GAAA,8HAAA,CAAA,oBAAiB,AAAD,EAAE;QACvB,SAAS,IAAI,OAAO;IACtB;AACF;AAEA,MAAM,UAAU,CAAC,MACf,CAAA,GAAA,uLAAA,CAAA,sBAAmB,AAAD,EAAE;QAClB,UAAU;QACV;QACA,QAAQ,8HAAA,CAAA,YAAS;QACjB,eAAe,IAAM,cAAc;QACnC,SACE,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,gBACb,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE;YACd,QAAQ,KAAK,CACX,CAAC,iBAAiB,EAAE,QAAQ,YAAY,EAAE,EAAE,MAAM,OAAO,EAAE;QAE/D,IACA;IACR"}},
    {"offset": {"line": 651, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}
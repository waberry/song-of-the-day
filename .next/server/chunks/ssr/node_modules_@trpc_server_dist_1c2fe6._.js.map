{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/observable/observable.mjs"],"sourcesContent":["/** @public */ function isObservable(x) {\n    return typeof x === 'object' && x !== null && 'subscribe' in x;\n}\n/** @public */ function observable(subscribe) {\n    const self = {\n        subscribe (observer) {\n            let teardownRef = null;\n            let isDone = false;\n            let unsubscribed = false;\n            let teardownImmediately = false;\n            function unsubscribe() {\n                if (teardownRef === null) {\n                    teardownImmediately = true;\n                    return;\n                }\n                if (unsubscribed) {\n                    return;\n                }\n                unsubscribed = true;\n                if (typeof teardownRef === 'function') {\n                    teardownRef();\n                } else if (teardownRef) {\n                    teardownRef.unsubscribe();\n                }\n            }\n            teardownRef = subscribe({\n                next (value) {\n                    if (isDone) {\n                        return;\n                    }\n                    observer.next?.(value);\n                },\n                error (err) {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.error?.(err);\n                    unsubscribe();\n                },\n                complete () {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.complete?.();\n                    unsubscribe();\n                }\n            });\n            if (teardownImmediately) {\n                unsubscribe();\n            }\n            return {\n                unsubscribe\n            };\n        },\n        pipe (...operations) {\n            return operations.reduce(pipeReducer, self);\n        }\n    };\n    return self;\n}\nfunction pipeReducer(prev, fn) {\n    return fn(prev);\n}\n/** @internal */ function observableToPromise(observable) {\n    const ac = new AbortController();\n    const promise = new Promise((resolve, reject)=>{\n        let isDone = false;\n        function onDone() {\n            if (isDone) {\n                return;\n            }\n            isDone = true;\n            obs$.unsubscribe();\n        }\n        ac.signal.addEventListener('abort', ()=>{\n            reject(ac.signal.reason);\n        });\n        const obs$ = observable.subscribe({\n            next (data) {\n                isDone = true;\n                resolve(data);\n                onDone();\n            },\n            error (data) {\n                reject(data);\n            },\n            complete () {\n                ac.abort();\n                onDone();\n            }\n        });\n    });\n    return promise;\n}\n/**\n * @internal\n */ function observableToReadableStream(observable) {\n    let unsub = null;\n    return new ReadableStream({\n        start (controller) {\n            unsub = observable.subscribe({\n                next (data) {\n                    controller.enqueue({\n                        ok: true,\n                        value: data\n                    });\n                },\n                error (error) {\n                    controller.enqueue({\n                        ok: false,\n                        error\n                    });\n                    controller.close();\n                },\n                complete () {\n                    controller.close();\n                }\n            });\n        },\n        cancel () {\n            unsub?.unsubscribe();\n        }\n    });\n}\n/** @internal */ function observableToAsyncIterable(observable) {\n    const stream = observableToReadableStream(observable);\n    const reader = stream.getReader();\n    const iterator = {\n        async next () {\n            const value = await reader.read();\n            if (value.done) {\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n            const { value: result  } = value;\n            if (!result.ok) {\n                throw result.error;\n            }\n            return {\n                value: result.value,\n                done: false\n            };\n        },\n        async return () {\n            await reader.cancel();\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n    };\n    return {\n        [Symbol.asyncIterator] () {\n            return iterator;\n        }\n    };\n}\n\nexport { isObservable, observable, observableToAsyncIterable, observableToPromise };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 178, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/observable/operators.mjs"],"sourcesContent":["import { observable } from './observable.mjs';\n\nfunction map(project) {\n    return (source)=>{\n        return observable((destination)=>{\n            let index = 0;\n            const subscription = source.subscribe({\n                next (value) {\n                    destination.next(project(value, index++));\n                },\n                error (error) {\n                    destination.error(error);\n                },\n                complete () {\n                    destination.complete();\n                }\n            });\n            return subscription;\n        });\n    };\n}\nfunction share(_opts) {\n    return (source)=>{\n        let refCount = 0;\n        let subscription = null;\n        const observers = [];\n        function startIfNeeded() {\n            if (subscription) {\n                return;\n            }\n            subscription = source.subscribe({\n                next (value) {\n                    for (const observer of observers){\n                        observer.next?.(value);\n                    }\n                },\n                error (error) {\n                    for (const observer of observers){\n                        observer.error?.(error);\n                    }\n                },\n                complete () {\n                    for (const observer of observers){\n                        observer.complete?.();\n                    }\n                }\n            });\n        }\n        function resetIfNeeded() {\n            // \"resetOnRefCountZero\"\n            if (refCount === 0 && subscription) {\n                const _sub = subscription;\n                subscription = null;\n                _sub.unsubscribe();\n            }\n        }\n        return observable((subscriber)=>{\n            refCount++;\n            observers.push(subscriber);\n            startIfNeeded();\n            return {\n                unsubscribe () {\n                    refCount--;\n                    resetIfNeeded();\n                    const index = observers.findIndex((v)=>v === subscriber);\n                    if (index > -1) {\n                        observers.splice(index, 1);\n                    }\n                }\n            };\n        });\n    };\n}\nfunction tap(observer) {\n    return (source)=>{\n        return observable((destination)=>{\n            return source.subscribe({\n                next (value) {\n                    observer.next?.(value);\n                    destination.next(value);\n                },\n                error (error) {\n                    observer.error?.(error);\n                    destination.error(error);\n                },\n                complete () {\n                    observer.complete?.();\n                    destination.complete();\n                }\n            });\n        });\n    };\n}\n\nexport { map, share, tap };\n"],"names":[],"mappings":";;;;;;;;AAEA,SAAS,IAAI,OAAO;IAChB,OAAO,CAAC;QACJ,OAAO,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,CAAC;YACf,IAAI,QAAQ;YACZ,MAAM,eAAe,OAAO,SAAS,CAAC;gBAClC,MAAM,KAAK;oBACP,YAAY,IAAI,CAAC,QAAQ,OAAO;gBACpC;gBACA,OAAO,KAAK;oBACR,YAAY,KAAK,CAAC;gBACtB;gBACA;oBACI,YAAY,QAAQ;gBACxB;YACJ;YACA,OAAO;QACX;IACJ;AACJ;AACA,SAAS,MAAM,KAAK;IAChB,OAAO,CAAC;QACJ,IAAI,WAAW;QACf,IAAI,eAAe;QACnB,MAAM,YAAY,EAAE;QACpB,SAAS;YACL,IAAI,cAAc;gBACd;YACJ;YACA,eAAe,OAAO,SAAS,CAAC;gBAC5B,MAAM,KAAK;oBACP,KAAK,MAAM,YAAY,UAAU;wBAC7B,SAAS,IAAI,GAAG;oBACpB;gBACJ;gBACA,OAAO,KAAK;oBACR,KAAK,MAAM,YAAY,UAAU;wBAC7B,SAAS,KAAK,GAAG;oBACrB;gBACJ;gBACA;oBACI,KAAK,MAAM,YAAY,UAAU;wBAC7B,SAAS,QAAQ;oBACrB;gBACJ;YACJ;QACJ;QACA,SAAS;YACL,wBAAwB;YACxB,IAAI,aAAa,KAAK,cAAc;gBAChC,MAAM,OAAO;gBACb,eAAe;gBACf,KAAK,WAAW;YACpB;QACJ;QACA,OAAO,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,CAAC;YACf;YACA,UAAU,IAAI,CAAC;YACf;YACA,OAAO;gBACH;oBACI;oBACA;oBACA,MAAM,QAAQ,UAAU,SAAS,CAAC,CAAC,IAAI,MAAM;oBAC7C,IAAI,QAAQ,CAAC,GAAG;wBACZ,UAAU,MAAM,CAAC,OAAO;oBAC5B;gBACJ;YACJ;QACJ;IACJ;AACJ;AACA,SAAS,IAAI,QAAQ;IACjB,OAAO,CAAC;QACJ,OAAO,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,CAAC;YACf,OAAO,OAAO,SAAS,CAAC;gBACpB,MAAM,KAAK;oBACP,SAAS,IAAI,GAAG;oBAChB,YAAY,IAAI,CAAC;gBACrB;gBACA,OAAO,KAAK;oBACR,SAAS,KAAK,GAAG;oBACjB,YAAY,KAAK,CAAC;gBACtB;gBACA;oBACI,SAAS,QAAQ;oBACjB,YAAY,QAAQ;gBACxB;YACJ;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 278, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 286, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 301, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/createProxy.mjs"],"sourcesContent":["var _memo, _cacheKey;\nconst noop = ()=>{\n// noop\n};\nconst freezeIfAvailable = (obj)=>{\n    if (Object.freeze) {\n        Object.freeze(obj);\n    }\n};\nfunction createInnerProxy(callback, path, memo) {\n    const cacheKey = path.join('.');\n    (_memo = memo)[_cacheKey = cacheKey] ?? (_memo[_cacheKey] = new Proxy(noop, {\n        get (_obj, key) {\n            if (typeof key !== 'string' || key === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return createInnerProxy(callback, [\n                ...path,\n                key\n            ], memo);\n        },\n        apply (_1, _2, args) {\n            const lastOfPath = path[path.length - 1];\n            let opts = {\n                args,\n                path\n            };\n            // special handling for e.g. `trpc.hello.call(this, 'there')` and `trpc.hello.apply(this, ['there'])\n            if (lastOfPath === 'call') {\n                opts = {\n                    args: args.length >= 2 ? [\n                        args[1]\n                    ] : [],\n                    path: path.slice(0, -1)\n                };\n            } else if (lastOfPath === 'apply') {\n                opts = {\n                    args: args.length >= 2 ? args[1] : [],\n                    path: path.slice(0, -1)\n                };\n            }\n            freezeIfAvailable(opts.args);\n            freezeIfAvailable(opts.path);\n            return callback(opts);\n        }\n    }));\n    return memo[cacheKey];\n}\n/**\n * Creates a proxy that calls the callback with the path and arguments\n *\n * @internal\n */ const createRecursiveProxy = (callback)=>createInnerProxy(callback, [], Object.create(null));\n/**\n * Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n *\n * @internal\n */ const createFlatProxy = (callback)=>{\n    return new Proxy(noop, {\n        get (_obj, name) {\n            if (typeof name !== 'string' || name === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return callback(name);\n        }\n    });\n};\n\nexport { createFlatProxy, createRecursiveProxy };\n"],"names":[],"mappings":";;;;AAAA,IAAI,OAAO;AACX,MAAM,OAAO;AACb,OAAO;AACP;AACA,MAAM,oBAAoB,CAAC;IACvB,IAAI,OAAO,MAAM,EAAE;QACf,OAAO,MAAM,CAAC;IAClB;AACJ;AACA,SAAS,iBAAiB,QAAQ,EAAE,IAAI,EAAE,IAAI;IAC1C,MAAM,WAAW,KAAK,IAAI,CAAC;IAC3B,CAAC,QAAQ,IAAI,CAAC,CAAC,YAAY,SAAS,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,IAAI,MAAM,MAAM;QACxE,KAAK,IAAI,EAAE,GAAG;YACV,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ;gBAC3C,wDAAwD;gBACxD,wDAAwD;gBACxD,OAAO;YACX;YACA,OAAO,iBAAiB,UAAU;mBAC3B;gBACH;aACH,EAAE;QACP;QACA,OAAO,EAAE,EAAE,EAAE,EAAE,IAAI;YACf,MAAM,aAAa,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE;YACxC,IAAI,OAAO;gBACP;gBACA;YACJ;YACA,oGAAoG;YACpG,IAAI,eAAe,QAAQ;gBACvB,OAAO;oBACH,MAAM,KAAK,MAAM,IAAI,IAAI;wBACrB,IAAI,CAAC,EAAE;qBACV,GAAG,EAAE;oBACN,MAAM,KAAK,KAAK,CAAC,GAAG,CAAC;gBACzB;YACJ,OAAO,IAAI,eAAe,SAAS;gBAC/B,OAAO;oBACH,MAAM,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,EAAE,GAAG,EAAE;oBACrC,MAAM,KAAK,KAAK,CAAC,GAAG,CAAC;gBACzB;YACJ;YACA,kBAAkB,KAAK,IAAI;YAC3B,kBAAkB,KAAK,IAAI;YAC3B,OAAO,SAAS;QACpB;IACJ,EAAE;IACF,OAAO,IAAI,CAAC,SAAS;AACzB;AACA;;;;CAIC,GAAG,MAAM,uBAAuB,CAAC,WAAW,iBAAiB,UAAU,EAAE,EAAE,OAAO,MAAM,CAAC;AAC1F;;;;CAIC,GAAG,MAAM,kBAAkB,CAAC;IACzB,OAAO,IAAI,MAAM,MAAM;QACnB,KAAK,IAAI,EAAE,IAAI;YACX,IAAI,OAAO,SAAS,YAAY,SAAS,QAAQ;gBAC7C,wDAAwD;gBACxD,wDAAwD;gBACxD,OAAO;YACX;YACA,OAAO,SAAS;QACpB;IACJ;AACJ"}},
    {"offset": {"line": 377, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/error/formatter.mjs"],"sourcesContent":["const defaultFormatter = ({ shape  })=>{\n    return shape;\n};\n\nexport { defaultFormatter };\n"],"names":[],"mappings":";;;AAAA,MAAM,mBAAmB,CAAC,EAAE,KAAK,EAAG;IAChC,OAAO;AACX"}},
    {"offset": {"line": 389, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 394, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/rpc/codes.mjs"],"sourcesContent":["// reference: https://www.jsonrpc.org/specification\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */ const TRPC_ERROR_CODES_BY_KEY = {\n    /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */ PARSE_ERROR: -32700,\n    /**\n   * The JSON sent is not a valid Request object.\n   */ BAD_REQUEST: -32600,\n    // Internal JSON-RPC error\n    INTERNAL_SERVER_ERROR: -32603,\n    NOT_IMPLEMENTED: -32603,\n    BAD_GATEWAY: -32603,\n    SERVICE_UNAVAILABLE: -32603,\n    GATEWAY_TIMEOUT: -32603,\n    // Implementation specific errors\n    UNAUTHORIZED: -32001,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    UNSUPPORTED_MEDIA_TYPE: -32015,\n    UNPROCESSABLE_CONTENT: -32022,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\n// pure\nconst TRPC_ERROR_CODES_BY_NUMBER = {\n    [-32700]: 'PARSE_ERROR',\n    [-32600]: 'BAD_REQUEST',\n    [-32603]: 'INTERNAL_SERVER_ERROR',\n    [-32001]: 'UNAUTHORIZED',\n    [-32003]: 'FORBIDDEN',\n    [-32004]: 'NOT_FOUND',\n    [-32005]: 'METHOD_NOT_SUPPORTED',\n    [-32008]: 'TIMEOUT',\n    [-32009]: 'CONFLICT',\n    [-32012]: 'PRECONDITION_FAILED',\n    [-32013]: 'PAYLOAD_TOO_LARGE',\n    [-32015]: 'UNSUPPORTED_MEDIA_TYPE',\n    [-32022]: 'UNPROCESSABLE_CONTENT',\n    [-32029]: 'TOO_MANY_REQUESTS',\n    [-32099]: 'CLIENT_CLOSED_REQUEST'\n};\n\nexport { TRPC_ERROR_CODES_BY_KEY, TRPC_ERROR_CODES_BY_NUMBER };\n"],"names":[],"mappings":"AAAA,mDAAmD;AACnD;;;;;CAKC;;;;AAAG,MAAM,0BAA0B;IAChC;;;GAGD,GAAG,aAAa,CAAC;IAChB;;GAED,GAAG,aAAa,CAAC;IAChB,0BAA0B;IAC1B,uBAAuB,CAAC;IACxB,iBAAiB,CAAC;IAClB,aAAa,CAAC;IACd,qBAAqB,CAAC;IACtB,iBAAiB,CAAC;IAClB,iCAAiC;IACjC,cAAc,CAAC;IACf,WAAW,CAAC;IACZ,WAAW,CAAC;IACZ,sBAAsB,CAAC;IACvB,SAAS,CAAC;IACV,UAAU,CAAC;IACX,qBAAqB,CAAC;IACtB,mBAAmB,CAAC;IACpB,wBAAwB,CAAC;IACzB,uBAAuB,CAAC;IACxB,mBAAmB,CAAC;IACpB,uBAAuB,CAAC;AAC5B;AACA,OAAO;AACP,MAAM,6BAA6B;IAC/B,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;AACd"}},
    {"offset": {"line": 451, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 456, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/utils.mjs"],"sourcesContent":["/** @internal */ const unsetMarker = Symbol();\n/**\n * Ensures there are no duplicate keys when building a procedure.\n * @internal\n */ function mergeWithoutOverrides(obj1, ...objs) {\n    const newObj = Object.assign(Object.create(null), obj1);\n    for (const overrides of objs){\n        for(const key in overrides){\n            if (key in newObj && newObj[key] !== overrides[key]) {\n                throw new Error(`Duplicate key ${key}`);\n            }\n            newObj[key] = overrides[key];\n        }\n    }\n    return newObj;\n}\n/**\n * Check that value is object\n * @internal\n */ function isObject(value) {\n    return !!value && !Array.isArray(value) && typeof value === 'object';\n}\nfunction isFunction(fn) {\n    return typeof fn === 'function';\n}\n/**\n * Create an object without inheriting anything from `Object.prototype`\n * @internal\n */ function omitPrototype(obj) {\n    return Object.assign(Object.create(null), obj);\n}\nconst asyncIteratorsSupported = typeof Symbol === 'function' && !!Symbol.asyncIterator;\nfunction isAsyncIterable(value) {\n    return asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value;\n}\n/**\n * Run an IIFE\n */ const run = (fn)=>fn();\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\nfunction identity(it) {\n    return it;\n}\n/**\n * Generic runtime assertion function. Throws, if the condition is not `true`.\n *\n * Can be used as a slightly less dangerous variant of type assertions. Code\n * mistakes would be revealed at runtime then (hopefully during testing).\n */ function assert(condition, msg = 'no additional info') {\n    if (!condition) {\n        throw new Error(`AssertionError: ${msg}`);\n    }\n}\nfunction sleep(ms = 0) {\n    return new Promise((res)=>setTimeout(res, ms));\n}\n/**\n * Ponyfill for\n * [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n */ function abortSignalsAnyPonyfill(signals) {\n    if (typeof AbortSignal.any === 'function') {\n        return AbortSignal.any(signals);\n    }\n    const ac = new AbortController();\n    for (const signal of signals){\n        if (signal.aborted) {\n            trigger();\n        } else if (!ac.signal.aborted) {\n            signal.addEventListener('abort', trigger, {\n                once: true\n            });\n        }\n    }\n    return ac.signal;\n    function trigger() {\n        ac.abort();\n        for (const signal of signals){\n            signal.removeEventListener('abort', trigger);\n        }\n    }\n}\n\nexport { abortSignalsAnyPonyfill, assert, identity, isAsyncIterable, isFunction, isObject, mergeWithoutOverrides, noop, omitPrototype, run, sleep, unsetMarker };\n"],"names":[],"mappings":"AAAA,cAAc;;;;;;;;;;;;;;AAAG,MAAM,cAAc;AACrC;;;CAGC,GAAG,SAAS,sBAAsB,IAAI,EAAE,GAAG,IAAI;IAC5C,MAAM,SAAS,OAAO,MAAM,CAAC,OAAO,MAAM,CAAC,OAAO;IAClD,KAAK,MAAM,aAAa,KAAK;QACzB,IAAI,MAAM,OAAO,UAAU;YACvB,IAAI,OAAO,UAAU,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI,EAAE;gBACjD,MAAM,IAAI,MAAM,CAAC,cAAc,EAAE,IAAI,CAAC;YAC1C;YACA,MAAM,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI;QAChC;IACJ;IACA,OAAO;AACX;AACA;;;CAGC,GAAG,SAAS,SAAS,KAAK;IACvB,OAAO,CAAC,CAAC,SAAS,CAAC,MAAM,OAAO,CAAC,UAAU,OAAO,UAAU;AAChE;AACA,SAAS,WAAW,EAAE;IAClB,OAAO,OAAO,OAAO;AACzB;AACA;;;CAGC,GAAG,SAAS,cAAc,GAAG;IAC1B,OAAO,OAAO,MAAM,CAAC,OAAO,MAAM,CAAC,OAAO;AAC9C;AACA,MAAM,0BAA0B,OAAO,WAAW,cAAc,CAAC,CAAC,OAAO,aAAa;AACtF,SAAS,gBAAgB,KAAK;IAC1B,OAAO,2BAA2B,SAAS,UAAU,OAAO,aAAa,IAAI;AACjF;AACA;;CAEC,GAAG,MAAM,MAAM,CAAC,KAAK;AACtB,gEAAgE;AAChE,SAAS,QAAQ;AACjB,SAAS,SAAS,EAAE;IAChB,OAAO;AACX;AACA;;;;;CAKC,GAAG,SAAS,OAAO,SAAS,EAAE,MAAM,oBAAoB;IACrD,IAAI,CAAC,WAAW;QACZ,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,IAAI,CAAC;IAC5C;AACJ;AACA,SAAS,MAAM,KAAK,CAAC;IACjB,OAAO,IAAI,QAAQ,CAAC,MAAM,WAAW,KAAK;AAC9C;AACA;;;CAGC,GAAG,SAAS,wBAAwB,OAAO;IACxC,IAAI,OAAO,YAAY,GAAG,KAAK,YAAY;QACvC,OAAO,YAAY,GAAG,CAAC;IAC3B;IACA,MAAM,KAAK,IAAI;IACf,KAAK,MAAM,UAAU,QAAQ;QACzB,IAAI,OAAO,OAAO,EAAE;YAChB;QACJ,OAAO,IAAI,CAAC,GAAG,MAAM,CAAC,OAAO,EAAE;YAC3B,OAAO,gBAAgB,CAAC,SAAS,SAAS;gBACtC,MAAM;YACV;QACJ;IACJ;IACA,OAAO,GAAG,MAAM;IAChB,SAAS;QACL,GAAG,KAAK;QACR,KAAK,MAAM,UAAU,QAAQ;YACzB,OAAO,mBAAmB,CAAC,SAAS;QACxC;IACJ;AACJ"}},
    {"offset": {"line": 552, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 557, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/http/getHTTPStatusCode.mjs"],"sourcesContent":["import { TRPC_ERROR_CODES_BY_NUMBER } from '../rpc/codes.mjs';\nimport { isObject } from '../utils.mjs';\n\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    METHOD_NOT_SUPPORTED: 405,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    UNSUPPORTED_MEDIA_TYPE: 415,\n    UNPROCESSABLE_CONTENT: 422,\n    TOO_MANY_REQUESTS: 429,\n    CLIENT_CLOSED_REQUEST: 499,\n    INTERNAL_SERVER_ERROR: 500,\n    NOT_IMPLEMENTED: 501,\n    BAD_GATEWAY: 502,\n    SERVICE_UNAVAILABLE: 503,\n    GATEWAY_TIMEOUT: 504\n};\nconst HTTP_CODE_TO_JSONRPC2 = {\n    400: 'BAD_REQUEST',\n    401: 'UNAUTHORIZED',\n    403: 'FORBIDDEN',\n    404: 'NOT_FOUND',\n    405: 'METHOD_NOT_SUPPORTED',\n    408: 'TIMEOUT',\n    409: 'CONFLICT',\n    412: 'PRECONDITION_FAILED',\n    413: 'PAYLOAD_TOO_LARGE',\n    415: 'UNSUPPORTED_MEDIA_TYPE',\n    422: 'UNPROCESSABLE_CONTENT',\n    429: 'TOO_MANY_REQUESTS',\n    499: 'CLIENT_CLOSED_REQUEST',\n    500: 'INTERNAL_SERVER_ERROR',\n    501: 'NOT_IMPLEMENTED',\n    502: 'BAD_GATEWAY',\n    503: 'SERVICE_UNAVAILABLE',\n    504: 'GATEWAY_TIMEOUT'\n};\nfunction getStatusCodeFromKey(code) {\n    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\nfunction getStatusKeyFromCode(code) {\n    return HTTP_CODE_TO_JSONRPC2[code] ?? 'INTERNAL_SERVER_ERROR';\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if ('error' in res && isObject(res.error.data)) {\n            if (typeof res.error.data?.['httpStatus'] === 'number') {\n                return res.error.data['httpStatus'];\n            }\n            const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) {\n        return 207;\n    }\n    const httpStatus = httpStatuses.values().next().value;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n    return getStatusCodeFromKey(error.code);\n}\n\nexport { HTTP_CODE_TO_JSONRPC2, JSONRPC2_TO_HTTP_CODE, getHTTPStatusCode, getHTTPStatusCodeFromError, getStatusCodeFromKey, getStatusKeyFromCode };\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGA,MAAM,wBAAwB;IAC1B,aAAa;IACb,aAAa;IACb,cAAc;IACd,WAAW;IACX,WAAW;IACX,sBAAsB;IACtB,SAAS;IACT,UAAU;IACV,qBAAqB;IACrB,mBAAmB;IACnB,wBAAwB;IACxB,uBAAuB;IACvB,mBAAmB;IACnB,uBAAuB;IACvB,uBAAuB;IACvB,iBAAiB;IACjB,aAAa;IACb,qBAAqB;IACrB,iBAAiB;AACrB;AACA,MAAM,wBAAwB;IAC1B,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACT;AACA,SAAS,qBAAqB,IAAI;IAC9B,OAAO,qBAAqB,CAAC,KAAK,IAAI;AAC1C;AACA,SAAS,qBAAqB,IAAI;IAC9B,OAAO,qBAAqB,CAAC,KAAK,IAAI;AAC1C;AACA,SAAS,kBAAkB,IAAI;IAC3B,MAAM,MAAM,MAAM,OAAO,CAAC,QAAQ,OAAO;QACrC;KACH;IACD,MAAM,eAAe,IAAI,IAAI,IAAI,GAAG,CAAC,CAAC;QAClC,IAAI,WAAW,OAAO,CAAA,GAAA,6LAAA,CAAA,WAAQ,AAAD,EAAE,IAAI,KAAK,CAAC,IAAI,GAAG;YAC5C,IAAI,OAAO,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC,aAAa,KAAK,UAAU;gBACpD,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,aAAa;YACvC;YACA,MAAM,OAAO,oMAAA,CAAA,6BAA0B,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC;YACvD,OAAO,qBAAqB;QAChC;QACA,OAAO;IACX;IACA,IAAI,aAAa,IAAI,KAAK,GAAG;QACzB,OAAO;IACX;IACA,MAAM,aAAa,aAAa,MAAM,GAAG,IAAI,GAAG,KAAK;IACrD,oEAAoE;IACpE,OAAO;AACX;AACA,SAAS,2BAA2B,KAAK;IACrC,OAAO,qBAAqB,MAAM,IAAI;AAC1C"}},
    {"offset": {"line": 642, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 647, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/error/getErrorShape.mjs"],"sourcesContent":["import { getHTTPStatusCodeFromError } from '../http/getHTTPStatusCode.mjs';\nimport { TRPC_ERROR_CODES_BY_KEY } from '../rpc/codes.mjs';\n\n/**\n * @internal\n */ function getErrorShape(opts) {\n    const { path , error , config  } = opts;\n    const { code  } = opts.error;\n    const shape = {\n        message: error.message,\n        code: TRPC_ERROR_CODES_BY_KEY[code],\n        data: {\n            code,\n            httpStatus: getHTTPStatusCodeFromError(error)\n        }\n    };\n    if (config.isDev && typeof opts.error.stack === 'string') {\n        shape.data.stack = opts.error.stack;\n    }\n    if (typeof path === 'string') {\n        shape.data.path = path;\n    }\n    return config.errorFormatter({\n        ...opts,\n        shape\n    });\n}\n\nexport { getErrorShape };\n"],"names":[],"mappings":";;;;;;;;AAGA;;CAEC,GAAG,SAAS,cAAc,IAAI;IAC3B,MAAM,EAAE,IAAI,EAAG,KAAK,EAAG,MAAM,EAAG,GAAG;IACnC,MAAM,EAAE,IAAI,EAAG,GAAG,KAAK,KAAK;IAC5B,MAAM,QAAQ;QACV,SAAS,MAAM,OAAO;QACtB,MAAM,oMAAA,CAAA,0BAAuB,CAAC,KAAK;QACnC,MAAM;YACF;YACA,YAAY,CAAA,GAAA,iNAAA,CAAA,6BAA0B,AAAD,EAAE;QAC3C;IACJ;IACA,IAAI,OAAO,KAAK,IAAI,OAAO,KAAK,KAAK,CAAC,KAAK,KAAK,UAAU;QACtD,MAAM,IAAI,CAAC,KAAK,GAAG,KAAK,KAAK,CAAC,KAAK;IACvC;IACA,IAAI,OAAO,SAAS,UAAU;QAC1B,MAAM,IAAI,CAAC,IAAI,GAAG;IACtB;IACA,OAAO,OAAO,cAAc,CAAC;QACzB,GAAG,IAAI;QACP;IACJ;AACJ"}},
    {"offset": {"line": 680, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 685, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/error/TRPCError.mjs"],"sourcesContent":["import { isObject } from '../utils.mjs';\n\nclass UnknownCauseError extends Error {\n}\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    const type = typeof cause;\n    if (type === 'undefined' || type === 'function' || cause === null) {\n        return undefined;\n    }\n    // Primitive types just get wrapped in an error\n    if (type !== 'object') {\n        return new Error(String(cause));\n    }\n    // If it's an object, we'll create a synthetic error\n    if (isObject(cause)) {\n        const err = new UnknownCauseError();\n        for(const key in cause){\n            err[key] = cause[key];\n        }\n        return err;\n    }\n    return undefined;\n}\nfunction getTRPCErrorFromUnknown(cause) {\n    if (cause instanceof TRPCError) {\n        return cause;\n    }\n    if (cause instanceof Error && cause.name === 'TRPCError') {\n        // https://github.com/trpc/trpc/pull/4848\n        return cause;\n    }\n    const trpcError = new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        cause\n    });\n    // Inherit stack from error\n    if (cause instanceof Error && cause.stack) {\n        trpcError.stack = cause.stack;\n    }\n    return trpcError;\n}\nclass TRPCError extends Error {\n    constructor(opts){\n        const cause = getCauseFromUnknown(opts.cause);\n        const message = opts.message ?? cause?.message ?? opts.code;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        });\n        this.code = opts.code;\n        this.name = 'TRPCError';\n        if (!this.cause) {\n            // < ES2022 / < Node 16.9.0 compatability\n            this.cause = cause;\n        }\n    }\n}\n\nexport { TRPCError, getCauseFromUnknown, getTRPCErrorFromUnknown };\n"],"names":[],"mappings":";;;;;;;;AAEA,MAAM,0BAA0B;AAChC;AACA,SAAS,oBAAoB,KAAK;IAC9B,IAAI,iBAAiB,OAAO;QACxB,OAAO;IACX;IACA,MAAM,OAAO,OAAO;IACpB,IAAI,SAAS,eAAe,SAAS,cAAc,UAAU,MAAM;QAC/D,OAAO;IACX;IACA,+CAA+C;IAC/C,IAAI,SAAS,UAAU;QACnB,OAAO,IAAI,MAAM,OAAO;IAC5B;IACA,oDAAoD;IACpD,IAAI,CAAA,GAAA,6LAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ;QACjB,MAAM,MAAM,IAAI;QAChB,IAAI,MAAM,OAAO,MAAM;YACnB,GAAG,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI;QACzB;QACA,OAAO;IACX;IACA,OAAO;AACX;AACA,SAAS,wBAAwB,KAAK;IAClC,IAAI,iBAAiB,WAAW;QAC5B,OAAO;IACX;IACA,IAAI,iBAAiB,SAAS,MAAM,IAAI,KAAK,aAAa;QACtD,yCAAyC;QACzC,OAAO;IACX;IACA,MAAM,YAAY,IAAI,UAAU;QAC5B,MAAM;QACN;IACJ;IACA,2BAA2B;IAC3B,IAAI,iBAAiB,SAAS,MAAM,KAAK,EAAE;QACvC,UAAU,KAAK,GAAG,MAAM,KAAK;IACjC;IACA,OAAO;AACX;AACA,MAAM,kBAAkB;IACpB,YAAY,IAAI,CAAC;QACb,MAAM,QAAQ,oBAAoB,KAAK,KAAK;QAC5C,MAAM,UAAU,KAAK,OAAO,IAAI,OAAO,WAAW,KAAK,IAAI;QAC3D,6DAA6D;QAC7D,0DAA0D;QAC1D,KAAK,CAAC,SAAS;YACX;QACJ;QACA,IAAI,CAAC,IAAI,GAAG,KAAK,IAAI;QACrB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACb,yCAAyC;YACzC,IAAI,CAAC,KAAK,GAAG;QACjB;IACJ;AACJ"}},
    {"offset": {"line": 753, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 758, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/http/batchStreamFormatter.mjs"],"sourcesContent":["/**\n * Format a batch response as a line-delimited JSON stream\n * that the `unstable_httpBatchStreamLink` can parse:\n *\n * @example\n * ```ts\n * const formatter = getBatchStreamFormatter();\n * res.send(formatter(1, 'response #2'));\n * res.send(formatter(0, 'response #1'));\n * res.send(formatter.end());\n * ```\n *\n * Expected format:\n * ```json\n * {\"1\":\"response #2\"\n * ,\"0\":\"response #1\"\n * }\n * ```\n */ function getBatchStreamFormatter() {\n    let first = true;\n    function format(index, string) {\n        const prefix = first ? '{' : ',';\n        first = false;\n        return `${prefix}\"${index}\":${string}\\n`;\n    }\n    format.end = ()=>'}';\n    return format;\n}\n\nexport { getBatchStreamFormatter };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;CAkBC;;;AAAG,SAAS;IACT,IAAI,QAAQ;IACZ,SAAS,OAAO,KAAK,EAAE,MAAM;QACzB,MAAM,SAAS,QAAQ,MAAM;QAC7B,QAAQ;QACR,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,MAAM,EAAE,EAAE,OAAO,EAAE,CAAC;IAC5C;IACA,OAAO,GAAG,GAAG,IAAI;IACjB,OAAO;AACX"}},
    {"offset": {"line": 790, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 795, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/http/parseConnectionParams.mjs"],"sourcesContent":["import { TRPCError } from '../error/TRPCError.mjs';\nimport { isObject } from '../utils.mjs';\n\nfunction parseConnectionParamsFromUnknown(parsed) {\n    try {\n        if (parsed === null) {\n            return null;\n        }\n        if (!isObject(parsed)) {\n            throw new Error('Expected object');\n        }\n        const nonStringValues = Object.entries(parsed).filter(([_key, value])=>typeof value !== 'string');\n        if (nonStringValues.length > 0) {\n            throw new Error(`Expected connectionParams to be string values. Got ${nonStringValues.map(([key, value])=>`${key}: ${typeof value}`).join(', ')}`);\n        }\n        return parsed;\n    } catch (cause) {\n        throw new TRPCError({\n            code: 'PARSE_ERROR',\n            message: 'Invalid connection params shape',\n            cause\n        });\n    }\n}\nfunction parseConnectionParamsFromString(str) {\n    let parsed;\n    try {\n        parsed = JSON.parse(str);\n    } catch (cause) {\n        throw new TRPCError({\n            code: 'PARSE_ERROR',\n            message: 'Not JSON-parsable query params',\n            cause\n        });\n    }\n    return parseConnectionParamsFromUnknown(parsed);\n}\n\nexport { parseConnectionParamsFromString, parseConnectionParamsFromUnknown };\n"],"names":[],"mappings":";;;;;;;;;AAGA,SAAS,iCAAiC,MAAM;IAC5C,IAAI;QACA,IAAI,WAAW,MAAM;YACjB,OAAO;QACX;QACA,IAAI,CAAC,CAAA,GAAA,6LAAA,CAAA,WAAQ,AAAD,EAAE,SAAS;YACnB,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,kBAAkB,OAAO,OAAO,CAAC,QAAQ,MAAM,CAAC,CAAC,CAAC,MAAM,MAAM,GAAG,OAAO,UAAU;QACxF,IAAI,gBAAgB,MAAM,GAAG,GAAG;YAC5B,MAAM,IAAI,MAAM,CAAC,mDAAmD,EAAE,gBAAgB,GAAG,CAAC,CAAC,CAAC,KAAK,MAAM,GAAG,CAAC,EAAE,IAAI,EAAE,EAAE,OAAO,MAAM,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC;QACrJ;QACA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;YAChB,MAAM;YACN,SAAS;YACT;QACJ;IACJ;AACJ;AACA,SAAS,gCAAgC,GAAG;IACxC,IAAI;IACJ,IAAI;QACA,SAAS,KAAK,KAAK,CAAC;IACxB,EAAE,OAAO,OAAO;QACZ,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;YAChB,MAAM;YACN,SAAS;YACT;QACJ;IACJ;IACA,OAAO,iCAAiC;AAC5C"}},
    {"offset": {"line": 839, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 844, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/http/contentType.mjs"],"sourcesContent":["import { TRPCError } from '../error/TRPCError.mjs';\nimport { isObject, unsetMarker } from '../utils.mjs';\nimport { parseConnectionParamsFromString } from './parseConnectionParams.mjs';\n\n/**\n * Memoize a function that takes no arguments\n * @internal\n */ function memo(fn) {\n    let promise = null;\n    let value = unsetMarker;\n    return {\n        /**\n     * Lazily read the value\n     */ read: async ()=>{\n            if (value !== unsetMarker) {\n                return value;\n            }\n            if (promise === null) {\n                // dedupes promises and catches errors\n                promise = fn().catch((cause)=>{\n                    if (cause instanceof TRPCError) {\n                        throw cause;\n                    }\n                    throw new TRPCError({\n                        code: 'BAD_REQUEST',\n                        message: cause instanceof Error ? cause.message : 'Invalid input',\n                        cause\n                    });\n                });\n            }\n            value = await promise;\n            promise = null;\n            return value;\n        },\n        /**\n     * Get an already stored result\n     */ result: ()=>{\n            return value !== unsetMarker ? value : undefined;\n        }\n    };\n}\nconst jsonContentTypeHandler = {\n    isMatch (req) {\n        return !!req.headers.get('content-type')?.startsWith('application/json');\n    },\n    parse (opts) {\n        const { req  } = opts;\n        const isBatchCall = opts.searchParams.get('batch') === '1';\n        const paths = isBatchCall ? opts.path.split(',') : [\n            opts.path\n        ];\n        const getInputs = memo(async ()=>{\n            let inputs = undefined;\n            if (req.method === 'GET') {\n                const queryInput = opts.searchParams.get('input');\n                if (queryInput) {\n                    inputs = JSON.parse(queryInput);\n                }\n            } else {\n                inputs = await req.json();\n            }\n            if (inputs === undefined) {\n                return {};\n            }\n            if (!isBatchCall) {\n                return {\n                    0: opts.router._def._config.transformer.input.deserialize(inputs)\n                };\n            }\n            if (!isObject(inputs)) {\n                throw new TRPCError({\n                    code: 'BAD_REQUEST',\n                    message: '\"input\" needs to be an object when doing a batch call'\n                });\n            }\n            const acc = {};\n            for (const index of paths.keys()){\n                const input = inputs[index];\n                if (input !== undefined) {\n                    acc[index] = opts.router._def._config.transformer.input.deserialize(input);\n                }\n            }\n            return acc;\n        });\n        const calls = paths.map((path, index)=>{\n            const procedure = opts.router._def.procedures[path] ?? null;\n            return {\n                path,\n                procedure,\n                getRawInput: async ()=>{\n                    const inputs = await getInputs.read();\n                    let input = inputs[index];\n                    if (procedure?._def.type === 'subscription') {\n                        const lastEventId = opts.headers.get('last-event-id') ?? opts.searchParams.get('lastEventId') ?? opts.searchParams.get('Last-Event-Id');\n                        if (lastEventId) {\n                            if (isObject(input)) {\n                                input = {\n                                    ...input,\n                                    lastEventId: lastEventId\n                                };\n                            } else {\n                                input ?? (input = {\n                                    lastEventId: lastEventId\n                                });\n                            }\n                        }\n                    }\n                    return input;\n                },\n                result: ()=>{\n                    return getInputs.result()?.[index];\n                }\n            };\n        });\n        const types = new Set(calls.map((call)=>call.procedure?._def.type).filter(Boolean));\n        /* istanbul ignore if -- @preserve */ if (types.size > 1) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                message: `Cannot mix procedure types in call: ${Array.from(types).join(', ')}`\n            });\n        }\n        const type = types.values().next().value ?? 'unknown';\n        const connectionParamsStr = opts.searchParams.get('connectionParams');\n        const info = {\n            isBatchCall,\n            accept: req.headers.get('trpc-accept'),\n            calls,\n            type,\n            connectionParams: connectionParamsStr === null ? null : parseConnectionParamsFromString(connectionParamsStr),\n            signal: req.signal\n        };\n        return info;\n    }\n};\nconst formDataContentTypeHandler = {\n    isMatch (req) {\n        return !!req.headers.get('content-type')?.startsWith('multipart/form-data');\n    },\n    parse (opts) {\n        const { req  } = opts;\n        if (req.method !== 'POST') {\n            throw new TRPCError({\n                code: 'METHOD_NOT_SUPPORTED',\n                message: 'Only POST requests are supported for multipart/form-data requests'\n            });\n        }\n        const getInputs = memo(async ()=>{\n            const fd = await req.formData();\n            return fd;\n        });\n        return {\n            accept: null,\n            calls: [\n                {\n                    path: opts.path,\n                    getRawInput: getInputs.read,\n                    result: getInputs.result,\n                    procedure: opts.router._def.procedures[opts.path] ?? null\n                }\n            ],\n            isBatchCall: false,\n            type: 'mutation',\n            connectionParams: null,\n            signal: req.signal\n        };\n    }\n};\nconst octetStreamContentTypeHandler = {\n    isMatch (req) {\n        return !!req.headers.get('content-type')?.startsWith('application/octet-stream');\n    },\n    parse (opts) {\n        const { req  } = opts;\n        if (req.method !== 'POST') {\n            throw new TRPCError({\n                code: 'METHOD_NOT_SUPPORTED',\n                message: 'Only POST requests are supported for application/octet-stream requests'\n            });\n        }\n        const getInputs = memo(async ()=>{\n            return req.body;\n        });\n        return {\n            calls: [\n                {\n                    path: opts.path,\n                    getRawInput: getInputs.read,\n                    result: getInputs.result,\n                    procedure: opts.router._def.procedures[opts.path] ?? null\n                }\n            ],\n            isBatchCall: false,\n            accept: null,\n            type: 'mutation',\n            connectionParams: null,\n            signal: req.signal\n        };\n    }\n};\nconst handlers = [\n    jsonContentTypeHandler,\n    formDataContentTypeHandler,\n    octetStreamContentTypeHandler\n];\nfunction getContentTypeHandler(req) {\n    const handler = handlers.find((handler)=>handler.isMatch(req));\n    if (handler) {\n        return handler;\n    }\n    if (!handler && req.method === 'GET') {\n        // fallback to JSON for get requests so GET-requests can be opened in browser easily\n        return jsonContentTypeHandler;\n    }\n    throw new TRPCError({\n        code: 'UNSUPPORTED_MEDIA_TYPE',\n        message: req.headers.has('content-type') ? `Unsupported content-type \"${req.headers.get('content-type')}` : 'Missing content-type header'\n    });\n}\nfunction getRequestInfo(opts) {\n    const handler = getContentTypeHandler(opts.req);\n    return handler.parse(opts);\n}\n\nexport { getRequestInfo };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1073, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1078, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/http/contentTypeParsers.mjs"],"sourcesContent":["const octetInputParser = {\n    _input: null,\n    _output: null,\n    parse (input) {\n        if (input instanceof ReadableStream) {\n            return input;\n        }\n        throw new Error(`Parsed input was expected to be a ReadableStream but was: ${typeof input}`);\n    }\n};\n\nexport { octetInputParser };\n"],"names":[],"mappings":";;;AAAA,MAAM,mBAAmB;IACrB,QAAQ;IACR,SAAS;IACT,OAAO,KAAK;QACR,IAAI,iBAAiB,gBAAgB;YACjC,OAAO;QACX;QACA,MAAM,IAAI,MAAM,CAAC,0DAA0D,EAAE,OAAO,MAAM,CAAC;IAC/F;AACJ"}},
    {"offset": {"line": 1092, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1097, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/http/formDataToObject.mjs"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */ const isNumberString = (str)=>/^\\d+$/.test(str);\nfunction set(obj, path, value) {\n    if (path.length > 1) {\n        const newPath = [\n            ...path\n        ];\n        const key = newPath.shift();\n        const nextKey = newPath[0];\n        if (!obj[key]) {\n            obj[key] = isNumberString(nextKey) ? [] : {};\n        } else if (Array.isArray(obj[key]) && !isNumberString(nextKey)) {\n            obj[key] = Object.fromEntries(Object.entries(obj[key]));\n        }\n        set(obj[key], newPath, value);\n        return;\n    }\n    const p = path[0];\n    if (obj[p] === undefined) {\n        obj[p] = value;\n    } else if (Array.isArray(obj[p])) {\n        obj[p].push(value);\n    } else {\n        obj[p] = [\n            obj[p],\n            value\n        ];\n    }\n}\nfunction formDataToObject(formData) {\n    const obj = {};\n    for (const [key, value] of formData.entries()){\n        const parts = key.split(/[\\.\\[\\]]/).filter(Boolean);\n        set(obj, parts, value);\n    }\n    return obj;\n}\n\nexport { formDataToObject };\n"],"names":[],"mappings":"AAAA,2DAA2D;;;AAAG,MAAM,iBAAiB,CAAC,MAAM,QAAQ,IAAI,CAAC;AACzG,SAAS,IAAI,GAAG,EAAE,IAAI,EAAE,KAAK;IACzB,IAAI,KAAK,MAAM,GAAG,GAAG;QACjB,MAAM,UAAU;eACT;SACN;QACD,MAAM,MAAM,QAAQ,KAAK;QACzB,MAAM,UAAU,OAAO,CAAC,EAAE;QAC1B,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE;YACX,GAAG,CAAC,IAAI,GAAG,eAAe,WAAW,EAAE,GAAG,CAAC;QAC/C,OAAO,IAAI,MAAM,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,eAAe,UAAU;YAC5D,GAAG,CAAC,IAAI,GAAG,OAAO,WAAW,CAAC,OAAO,OAAO,CAAC,GAAG,CAAC,IAAI;QACzD;QACA,IAAI,GAAG,CAAC,IAAI,EAAE,SAAS;QACvB;IACJ;IACA,MAAM,IAAI,IAAI,CAAC,EAAE;IACjB,IAAI,GAAG,CAAC,EAAE,KAAK,WAAW;QACtB,GAAG,CAAC,EAAE,GAAG;IACb,OAAO,IAAI,MAAM,OAAO,CAAC,GAAG,CAAC,EAAE,GAAG;QAC9B,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC;IAChB,OAAO;QACH,GAAG,CAAC,EAAE,GAAG;YACL,GAAG,CAAC,EAAE;YACN;SACH;IACL;AACJ;AACA,SAAS,iBAAiB,QAAQ;IAC9B,MAAM,MAAM,CAAC;IACb,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,SAAS,OAAO,GAAG;QAC1C,MAAM,QAAQ,IAAI,KAAK,CAAC,YAAY,MAAM,CAAC;QAC3C,IAAI,KAAK,OAAO;IACpB;IACA,OAAO;AACX"}},
    {"offset": {"line": 1137, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1142, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/stream/utils/createDeferred.mjs"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */ function createDeferred() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve: resolve,\n        reject: reject\n    };\n}\n\nexport { createDeferred };\n"],"names":[],"mappings":"AAAA,2DAA2D;;;AAAG,SAAS;IACnE,IAAI;IACJ,IAAI;IACJ,MAAM,UAAU,IAAI,QAAQ,CAAC,KAAK;QAC9B,UAAU;QACV,SAAS;IACb;IACA,OAAO;QACH;QACA,SAAS;QACT,QAAQ;IACZ;AACJ"}},
    {"offset": {"line": 1159, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1164, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/stream/utils/createReadableStream.mjs"],"sourcesContent":["import { createDeferred } from './createDeferred.mjs';\n\n// ---------- utils\nconst cancelledStreamSymbol = Symbol();\n/**\n * One-off readable stream\n */ function createReadableStream() {\n    let controller = null;\n    const deferred = createDeferred();\n    let cancelled = false;\n    const readable = new ReadableStream({\n        start (c) {\n            controller = c;\n        },\n        cancel () {\n            deferred.resolve(cancelledStreamSymbol);\n            cancelled = true;\n        }\n    });\n    return {\n        readable,\n        controller,\n        cancelledPromise: deferred.promise,\n        cancelled () {\n            return cancelled;\n        }\n    };\n}\nfunction isCancelledStreamResult(v) {\n    return v === cancelledStreamSymbol;\n}\n\nexport { createReadableStream, isCancelledStreamResult };\n"],"names":[],"mappings":";;;;;;;AAEA,mBAAmB;AACnB,MAAM,wBAAwB;AAC9B;;CAEC,GAAG,SAAS;IACT,IAAI,aAAa;IACjB,MAAM,WAAW,CAAA,GAAA,yNAAA,CAAA,iBAAc,AAAD;IAC9B,IAAI,YAAY;IAChB,MAAM,WAAW,IAAI,eAAe;QAChC,OAAO,CAAC;YACJ,aAAa;QACjB;QACA;YACI,SAAS,OAAO,CAAC;YACjB,YAAY;QAChB;IACJ;IACA,OAAO;QACH;QACA;QACA,kBAAkB,SAAS,OAAO;QAClC;YACI,OAAO;QACX;IACJ;AACJ;AACA,SAAS,wBAAwB,CAAC;IAC9B,OAAO,MAAM;AACjB"}},
    {"offset": {"line": 1201, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1206, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/stream/jsonl.mjs"],"sourcesContent":["import { getTRPCErrorFromUnknown } from '../error/TRPCError.mjs';\nimport { isObject, isFunction, isAsyncIterable, run } from '../utils.mjs';\nimport { createDeferred } from './utils/createDeferred.mjs';\nimport { createReadableStream, isCancelledStreamResult } from './utils/createReadableStream.mjs';\n\n// ---------- types\nconst CHUNK_VALUE_TYPE_PROMISE = 0;\nconst CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;\nconst PROMISE_STATUS_FULFILLED = 0;\nconst PROMISE_STATUS_REJECTED = 1;\nconst ASYNC_ITERABLE_STATUS_RETURN = 0;\nconst ASYNC_ITERABLE_STATUS_VALUE = 1;\nconst ASYNC_ITERABLE_STATUS_ERROR = 2;\nfunction isPromise(value) {\n    return (isObject(value) || isFunction(value)) && typeof value?.['then'] === 'function' && typeof value?.['catch'] === 'function';\n}\nclass MaxDepthError extends Error {\n    constructor(path){\n        super('Max depth reached at path: ' + path.join('.'));\n        this.path = path;\n    }\n}\nfunction createBatchStreamProducer(opts) {\n    const { data  } = opts;\n    let counter = 0;\n    const placeholder = 0;\n    const stream = createReadableStream();\n    const pending = new Set();\n    function maybeClose() {\n        if (pending.size === 0 && !stream.cancelled()) {\n            stream.controller.close();\n        }\n    }\n    function dehydratePromise(promise, path) {\n        //\n        const error = checkMaxDepth(path);\n        if (error) {\n            promise.catch(()=>{\n            // ignore\n            });\n            promise = Promise.reject(error);\n        }\n        const idx = counter++;\n        pending.add(idx);\n        Promise.race([\n            promise,\n            stream.cancelledPromise\n        ]).then((it)=>{\n            if (isCancelledStreamResult(it)) {\n                return;\n            }\n            stream.controller.enqueue([\n                idx,\n                PROMISE_STATUS_FULFILLED,\n                dehydrate(it, path)\n            ]);\n        }).catch((cause)=>{\n            opts.onError?.({\n                error: cause,\n                path\n            });\n            stream.controller.enqueue([\n                idx,\n                PROMISE_STATUS_REJECTED,\n                opts.formatError?.({\n                    error: cause,\n                    path\n                })\n            ]);\n        }).finally(()=>{\n            pending.delete(idx);\n            maybeClose();\n        });\n        return idx;\n    }\n    function dehydrateAsyncIterable(iterable, path) {\n        const error = checkMaxDepth(path);\n        if (error) {\n            iterable = {\n                [Symbol.asyncIterator] () {\n                    throw error;\n                }\n            };\n        }\n        const idx = counter++;\n        pending.add(idx);\n        run(async ()=>{\n            const iterator = iterable[Symbol.asyncIterator]();\n            while(true){\n                const next = await Promise.race([\n                    iterator.next().catch(getTRPCErrorFromUnknown),\n                    stream.cancelledPromise\n                ]);\n                if (next instanceof Error) {\n                    opts.onError?.({\n                        error: next,\n                        path\n                    });\n                    stream.controller.enqueue([\n                        idx,\n                        ASYNC_ITERABLE_STATUS_ERROR,\n                        opts.formatError?.({\n                            error: next,\n                            path\n                        })\n                    ]);\n                    return;\n                }\n                if (isCancelledStreamResult(next)) {\n                    await iterator.return?.();\n                    break;\n                }\n                if (next.done) {\n                    stream.controller.enqueue([\n                        idx,\n                        ASYNC_ITERABLE_STATUS_RETURN,\n                        dehydrate(next.value, path)\n                    ]);\n                    break;\n                }\n                stream.controller.enqueue([\n                    idx,\n                    ASYNC_ITERABLE_STATUS_VALUE,\n                    dehydrate(next.value, path)\n                ]);\n            }\n            pending.delete(idx);\n            maybeClose();\n        }).catch((cause)=>{\n            // this shouldn't happen, but node crashes if we don't catch it\n            opts.onError?.({\n                error: new Error('You found a bug - please report it on https://github.com/trpc/trpc', // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore https://github.com/tc39/proposal-error-cause\n                {\n                    cause\n                }),\n                path\n            });\n        });\n        return idx;\n    }\n    function checkMaxDepth(path) {\n        if (opts.maxDepth && path.length > opts.maxDepth) {\n            return new MaxDepthError(path);\n        }\n        return null;\n    }\n    function dehydrateAsync(value, path) {\n        if (isPromise(value)) {\n            return [\n                CHUNK_VALUE_TYPE_PROMISE,\n                dehydratePromise(value, path)\n            ];\n        }\n        if (isAsyncIterable(value)) {\n            if (opts.maxDepth && path.length >= opts.maxDepth) {\n                throw new Error('Max depth reached');\n            }\n            return [\n                CHUNK_VALUE_TYPE_ASYNC_ITERABLE,\n                dehydrateAsyncIterable(value, path)\n            ];\n        }\n        return null;\n    }\n    function dehydrate(value, path) {\n        if (value === undefined) {\n            return [\n                []\n            ];\n        }\n        if (!isObject(value)) {\n            return [\n                [\n                    value\n                ]\n            ];\n        }\n        const reg = dehydrateAsync(value, path);\n        if (reg) {\n            return [\n                [\n                    placeholder\n                ],\n                [\n                    null,\n                    ...reg\n                ]\n            ];\n        }\n        const newObj = {};\n        const asyncValues = [];\n        for (const [key, item] of Object.entries(value)){\n            const transformed = dehydrateAsync(item, [\n                ...path,\n                key\n            ]);\n            if (!transformed) {\n                newObj[key] = item;\n                continue;\n            }\n            newObj[key] = placeholder;\n            asyncValues.push([\n                key,\n                ...transformed\n            ]);\n        }\n        return [\n            [\n                newObj\n            ],\n            ...asyncValues\n        ];\n    }\n    const newHead = {};\n    for (const [key, item] of Object.entries(data)){\n        newHead[key] = dehydrate(item, [\n            key\n        ]);\n    }\n    return [\n        newHead,\n        stream.readable\n    ];\n}\n/**\n * JSON Lines stream producer\n * @see https://jsonlines.org/\n */ function jsonlStreamProducer(opts) {\n    let [head, stream] = createBatchStreamProducer(opts);\n    const { serialize  } = opts;\n    if (serialize) {\n        head = serialize(head);\n        stream = stream.pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                controller.enqueue(serialize(chunk));\n            }\n        }));\n    }\n    return stream.pipeThrough(new TransformStream({\n        start (controller) {\n            controller.enqueue(JSON.stringify(head) + '\\n');\n        },\n        transform (chunk, controller) {\n            controller.enqueue(JSON.stringify(chunk) + '\\n');\n        }\n    })).pipeThrough(new TextEncoderStream());\n}\nclass StreamInterruptedError extends Error {\n    constructor(cause){\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super('Invalid response or stream interrupted', {\n            cause\n        });\n    }\n}\nclass AsyncError extends Error {\n    constructor(data){\n        super('Received error from server');\n        this.data = data;\n    }\n}\nconst nodeJsStreamToReaderEsque = (source)=>{\n    return {\n        getReader () {\n            const { readable , controller  } = createReadableStream();\n            source.on('data', (chunk)=>{\n                controller.enqueue(chunk);\n            });\n            source.on('end', ()=>{\n                controller.close();\n            });\n            source.on('error', (error)=>{\n                controller.error(error);\n            });\n            return readable.getReader();\n        }\n    };\n};\nfunction createLineAccumulator(from) {\n    const reader = 'getReader' in from ? from.getReader() : nodeJsStreamToReaderEsque(from).getReader();\n    let lineAggregate = '';\n    return new ReadableStream({\n        async pull (controller) {\n            const { done , value  } = await reader.read();\n            if (done) {\n                controller.close();\n            } else {\n                controller.enqueue(value);\n            }\n        },\n        cancel () {\n            return reader.cancel();\n        }\n    }).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            lineAggregate += chunk;\n            const parts = lineAggregate.split('\\n');\n            lineAggregate = parts.pop() ?? '';\n            for (const part of parts){\n                controller.enqueue(part);\n            }\n        }\n    }));\n}\nfunction createConsumerStream(from) {\n    const stream = createLineAccumulator(from);\n    let sentHead = false;\n    return stream.pipeThrough(new TransformStream({\n        transform (line, controller) {\n            if (!sentHead) {\n                const head = JSON.parse(line);\n                controller.enqueue(head);\n                sentHead = true;\n            } else {\n                const chunk = JSON.parse(line);\n                controller.enqueue(chunk);\n            }\n        }\n    }));\n}\n/**\n * JSON Lines stream consumer\n * @see https://jsonlines.org/\n */ async function jsonlStreamConsumer(opts) {\n    const { deserialize =(v)=>v  } = opts;\n    let source = createConsumerStream(opts.from);\n    if (deserialize) {\n        source = source.pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                controller.enqueue(deserialize(chunk));\n            }\n        }));\n    }\n    let headDeferred = createDeferred();\n    const chunkDeferred = new Map();\n    const controllers = new Map();\n    const maybeAbort = ()=>{\n        if (chunkDeferred.size === 0 && Array.from(controllers.values()).every((it)=>it.returned)) {\n            // nothing is listening to the stream anymore\n            opts.abortController?.abort();\n        }\n    };\n    function hydrateChunkDefinition(value) {\n        const [_path, type, chunkId] = value;\n        const { readable , controller  } = createReadableStream();\n        const wrapper = {\n            controller,\n            returned: false\n        };\n        controllers.set(chunkId, wrapper);\n        // resolve chunk deferred if it exists\n        const deferred = chunkDeferred.get(chunkId);\n        if (deferred) {\n            deferred.resolve(wrapper);\n            chunkDeferred.delete(chunkId);\n        }\n        switch(type){\n            case CHUNK_VALUE_TYPE_PROMISE:\n                {\n                    return new Promise((resolve, reject)=>{\n                        // listen for next value in the stream\n                        const reader = readable.getReader();\n                        reader.read().then((it)=>{\n                            if (it.done) {\n                                reject(new Error('Promise chunk ended without value'));\n                                return;\n                            }\n                            if (it.value instanceof StreamInterruptedError) {\n                                reject(it.value);\n                                return;\n                            }\n                            const value = it.value;\n                            const [_chunkId, status, data] = value;\n                            switch(status){\n                                case PROMISE_STATUS_FULFILLED:\n                                    resolve(hydrate(data));\n                                    break;\n                                case PROMISE_STATUS_REJECTED:\n                                    reject(opts.formatError?.({\n                                        error: data\n                                    }) ?? new AsyncError(data));\n                                    break;\n                            }\n                        }).catch(reject).finally(()=>{\n                            // reader.releaseLock();\n                            controllers.delete(chunkId);\n                            maybeAbort();\n                        });\n                    });\n                }\n            case CHUNK_VALUE_TYPE_ASYNC_ITERABLE:\n                {\n                    return {\n                        [Symbol.asyncIterator]: ()=>{\n                            const reader = readable.getReader();\n                            const iterator = {\n                                next: async ()=>{\n                                    const { done , value  } = await reader.read();\n                                    if (value instanceof StreamInterruptedError) {\n                                        throw value;\n                                    }\n                                    if (done) {\n                                        controllers.delete(chunkId);\n                                        maybeAbort();\n                                        return {\n                                            done: true,\n                                            value: undefined\n                                        };\n                                    }\n                                    const [_chunkId, status, data] = value;\n                                    switch(status){\n                                        case ASYNC_ITERABLE_STATUS_VALUE:\n                                            return {\n                                                done: false,\n                                                value: hydrate(data)\n                                            };\n                                        case ASYNC_ITERABLE_STATUS_RETURN:\n                                            controllers.delete(chunkId);\n                                            maybeAbort();\n                                            return {\n                                                done: true,\n                                                value: hydrate(data)\n                                            };\n                                        case ASYNC_ITERABLE_STATUS_ERROR:\n                                            controllers.delete(chunkId);\n                                            maybeAbort();\n                                            throw opts.formatError?.({\n                                                error: data\n                                            }) ?? new AsyncError(data);\n                                    }\n                                },\n                                return: async ()=>{\n                                    wrapper.returned = true;\n                                    maybeAbort();\n                                    return {\n                                        done: true,\n                                        value: undefined\n                                    };\n                                }\n                            };\n                            return iterator;\n                        }\n                    };\n                }\n        }\n    }\n    function hydrate(value) {\n        const [[data], ...asyncProps] = value;\n        for (const value1 of asyncProps){\n            const [key] = value1;\n            const hydrated = hydrateChunkDefinition(value1);\n            if (key === null) {\n                return hydrated;\n            }\n            data[key] = hydrated;\n        }\n        return data;\n    }\n    const closeOrAbort = (reason)=>{\n        const error = new StreamInterruptedError(reason);\n        headDeferred?.reject(error);\n        for (const deferred of chunkDeferred.values()){\n            deferred.reject(error);\n        }\n        chunkDeferred.clear();\n        for (const { controller  } of controllers.values()){\n            controller.enqueue(error);\n            controller.close();\n        }\n        controllers.clear();\n    };\n    source.pipeTo(new WritableStream({\n        async write (chunkOrHead) {\n            if (headDeferred) {\n                const head = chunkOrHead;\n                for (const [key, value] of Object.entries(chunkOrHead)){\n                    const parsed = hydrate(value);\n                    head[key] = parsed;\n                }\n                headDeferred.resolve(head);\n                headDeferred = null;\n                return;\n            }\n            const chunk = chunkOrHead;\n            const [idx] = chunk;\n            let wrapper = controllers.get(idx);\n            if (!wrapper) {\n                let deferred = chunkDeferred.get(idx);\n                if (!deferred) {\n                    deferred = createDeferred();\n                    chunkDeferred.set(idx, deferred);\n                }\n                wrapper = await deferred.promise;\n            }\n            wrapper.controller.enqueue(chunk);\n        },\n        close: closeOrAbort,\n        abort: closeOrAbort\n    })).catch((error)=>{\n        opts.onError?.({\n            error\n        });\n        closeOrAbort(error);\n    });\n    return [\n        await headDeferred.promise,\n        {\n            controllers\n        }\n    ];\n}\n\nexport { isPromise, jsonlStreamConsumer, jsonlStreamProducer };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1728, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1733, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/stream/tracked.mjs"],"sourcesContent":["const trackedSymbol = Symbol();\n/**\n * Produce a typed server-sent event message\n * @deprecated use `tracked(id, data)` instead\n */ function sse(event) {\n    return tracked(event.id, event.data);\n}\nfunction isTrackedEnvelope(value) {\n    return Array.isArray(value) && value[2] === trackedSymbol;\n}\n/**\n * Automatically track an event so that it can be resumed from a given id if the connection is lost\n */ function tracked(id, data) {\n    if (id === '') {\n        // This limitation could be removed by using different SSE event names / channels for tracked event and non-tracked event\n        throw new Error('`id` must not be an empty string as empty string is the same as not setting the id at all');\n    }\n    return [\n        id,\n        data,\n        trackedSymbol\n    ];\n}\n\nexport { isTrackedEnvelope, sse, tracked };\n"],"names":[],"mappings":";;;;;AAAA,MAAM,gBAAgB;AACtB;;;CAGC,GAAG,SAAS,IAAI,KAAK;IAClB,OAAO,QAAQ,MAAM,EAAE,EAAE,MAAM,IAAI;AACvC;AACA,SAAS,kBAAkB,KAAK;IAC5B,OAAO,MAAM,OAAO,CAAC,UAAU,KAAK,CAAC,EAAE,KAAK;AAChD;AACA;;CAEC,GAAG,SAAS,QAAQ,EAAE,EAAE,IAAI;IACzB,IAAI,OAAO,IAAI;QACX,yHAAyH;QACzH,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;QACH;QACA;QACA;KACH;AACL"}},
    {"offset": {"line": 1762, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1767, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/stream/utils/promiseTimer.mjs"],"sourcesContent":["import { createDeferred } from './createDeferred.mjs';\n\nfunction createPromiseTimer(ms) {\n    let deferred = createDeferred();\n    let timeout = null;\n    const timer = {\n        get promise () {\n            return deferred.promise;\n        },\n        start,\n        reset,\n        clear\n    };\n    return timer;\n    function start() {\n        if (timeout != null) {\n            throw new Error('PromiseTimer already started.');\n        }\n        timeout = setTimeout(deferred.resolve, ms);\n        return timer;\n    }\n    function reset() {\n        clear();\n        deferred = createDeferred();\n        return timer;\n    }\n    function clear() {\n        if (timeout != null) {\n            clearTimeout(timeout);\n            timeout = null;\n        }\n        return timer;\n    }\n}\n\nexport { createPromiseTimer };\n"],"names":[],"mappings":";;;;;;AAEA,SAAS,mBAAmB,EAAE;IAC1B,IAAI,WAAW,CAAA,GAAA,yNAAA,CAAA,iBAAc,AAAD;IAC5B,IAAI,UAAU;IACd,MAAM,QAAQ;QACV,IAAI,WAAW;YACX,OAAO,SAAS,OAAO;QAC3B;QACA;QACA;QACA;IACJ;IACA,OAAO;IACP,SAAS;QACL,IAAI,WAAW,MAAM;YACjB,MAAM,IAAI,MAAM;QACpB;QACA,UAAU,WAAW,SAAS,OAAO,EAAE;QACvC,OAAO;IACX;IACA,SAAS;QACL;QACA,WAAW,CAAA,GAAA,yNAAA,CAAA,iBAAc,AAAD;QACxB,OAAO;IACX;IACA,SAAS;QACL,IAAI,WAAW,MAAM;YACjB,aAAa;YACb,UAAU;QACd;QACA,OAAO;IACX;AACJ"}},
    {"offset": {"line": 1806, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1811, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/stream/utils/asyncIterable.mjs"],"sourcesContent":["import { noop } from '../../utils.mjs';\nimport { createPromiseTimer } from './promiseTimer.mjs';\n\n/**\n * Derives a new {@link AsyncGenerator} based of {@link iterable}, that automatically stops with the\n * passed {@link cancel} promise.\n */ async function* withCancel(iterable, cancel) {\n    const cancelPromise = cancel.then(noop);\n    const iterator = iterable[Symbol.asyncIterator]();\n    while(true){\n        const result = await Promise.race([\n            iterator.next(),\n            cancelPromise\n        ]);\n        if (result == null) {\n            await iterator.return?.();\n            break;\n        }\n        if (result.done) {\n            break;\n        }\n        yield result.value;\n    }\n}\n/**\n * Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields its first\n * {@link count} values. Then, a grace period of {@link gracePeriodMs} is started in which further\n * values may still come through. After this period, the generator stops.\n */ async function* takeWithGrace(iterable, { count , gracePeriodMs , onCancel  }) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    const timer = createPromiseTimer(gracePeriodMs);\n    try {\n        while(true){\n            const result = await Promise.race([\n                iterator.next(),\n                timer.promise\n            ]);\n            if (result == null) {\n                // cancelled\n                await iterator.return?.();\n                break;\n            }\n            if (result.done) {\n                break;\n            }\n            yield result.value;\n            if (--count === 0) {\n                timer.start().promise.then(onCancel, noop);\n            }\n        }\n    } finally{\n        timer.clear();\n    }\n}\n\nexport { takeWithGrace, withCancel };\n"],"names":[],"mappings":";;;;;;;;;AAGA;;;CAGC,GAAG,gBAAgB,WAAW,QAAQ,EAAE,MAAM;IAC3C,MAAM,gBAAgB,OAAO,IAAI,CAAC,6LAAA,CAAA,OAAI;IACtC,MAAM,WAAW,QAAQ,CAAC,OAAO,aAAa,CAAC;IAC/C,MAAM,KAAK;QACP,MAAM,SAAS,MAAM,QAAQ,IAAI,CAAC;YAC9B,SAAS,IAAI;YACb;SACH;QACD,IAAI,UAAU,MAAM;YAChB,MAAM,SAAS,MAAM;YACrB;QACJ;QACA,IAAI,OAAO,IAAI,EAAE;YACb;QACJ;QACA,MAAM,OAAO,KAAK;IACtB;AACJ;AACA;;;;CAIC,GAAG,gBAAgB,cAAc,QAAQ,EAAE,EAAE,KAAK,EAAG,aAAa,EAAG,QAAQ,EAAG;IAC7E,MAAM,WAAW,QAAQ,CAAC,OAAO,aAAa,CAAC;IAC/C,MAAM,QAAQ,CAAA,GAAA,uNAAA,CAAA,qBAAkB,AAAD,EAAE;IACjC,IAAI;QACA,MAAM,KAAK;YACP,MAAM,SAAS,MAAM,QAAQ,IAAI,CAAC;gBAC9B,SAAS,IAAI;gBACb,MAAM,OAAO;aAChB;YACD,IAAI,UAAU,MAAM;gBAChB,YAAY;gBACZ,MAAM,SAAS,MAAM;gBACrB;YACJ;YACA,IAAI,OAAO,IAAI,EAAE;gBACb;YACJ;YACA,MAAM,OAAO,KAAK;YAClB,IAAI,EAAE,UAAU,GAAG;gBACf,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,UAAU,6LAAA,CAAA,OAAI;YAC7C;QACJ;IACJ,SAAS;QACL,MAAM,KAAK;IACf;AACJ"}},
    {"offset": {"line": 1872, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1877, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/stream/utils/withPing.mjs"],"sourcesContent":["import { createPromiseTimer } from './promiseTimer.mjs';\n\nconst PING_SYM = Symbol('ping');\nconst PING_RESULT = {\n    value: PING_SYM,\n    done: false\n};\n/**\n * Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields {@link PING_SYM}\n * whenever no value has been yielded for {@link pingIntervalMs}.\n */ async function* withPing(iterable, pingIntervalMs) {\n    const timer = createPromiseTimer(pingIntervalMs);\n    const iterator = iterable[Symbol.asyncIterator]();\n    while(true){\n        const nextPromise = iterator.next();\n        const pingPromise = timer.start().promise.then(()=>PING_RESULT);\n        let result;\n        try {\n            result = await Promise.race([\n                nextPromise,\n                pingPromise\n            ]);\n        } finally{\n            timer.clear();\n        }\n        if (result.done) {\n            return result.value;\n        }\n        yield result.value;\n        timer.reset();\n    }\n}\n\nexport { PING_SYM, withPing };\n"],"names":[],"mappings":";;;;;;;AAEA,MAAM,WAAW,OAAO;AACxB,MAAM,cAAc;IAChB,OAAO;IACP,MAAM;AACV;AACA;;;CAGC,GAAG,gBAAgB,SAAS,QAAQ,EAAE,cAAc;IACjD,MAAM,QAAQ,CAAA,GAAA,uNAAA,CAAA,qBAAkB,AAAD,EAAE;IACjC,MAAM,WAAW,QAAQ,CAAC,OAAO,aAAa,CAAC;IAC/C,MAAM,KAAK;QACP,MAAM,cAAc,SAAS,IAAI;QACjC,MAAM,cAAc,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI;QACnD,IAAI;QACJ,IAAI;YACA,SAAS,MAAM,QAAQ,IAAI,CAAC;gBACxB;gBACA;aACH;QACL,SAAS;YACL,MAAM,KAAK;QACf;QACA,IAAI,OAAO,IAAI,EAAE;YACb,OAAO,OAAO,KAAK;QACvB;QACA,MAAM,OAAO,KAAK;QAClB,MAAM,KAAK;IACf;AACJ"}},
    {"offset": {"line": 1915, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1920, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/stream/sse.mjs"],"sourcesContent":["import { getTRPCErrorFromUnknown } from '../error/TRPCError.mjs';\nimport { run, identity } from '../utils.mjs';\nimport { isTrackedEnvelope } from './tracked.mjs';\nimport { withCancel, takeWithGrace } from './utils/asyncIterable.mjs';\nimport { createDeferred } from './utils/createDeferred.mjs';\nimport { createReadableStream } from './utils/createReadableStream.mjs';\nimport { createPromiseTimer } from './utils/promiseTimer.mjs';\nimport { withPing, PING_SYM } from './utils/withPing.mjs';\n\nconst SERIALIZED_ERROR_EVENT = 'serialized-error';\n/**\n *\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */ function sseStreamProducer(opts) {\n    const stream = createReadableStream();\n    stream.controller.enqueue({\n        comment: 'connected'\n    });\n    const { serialize =identity  } = opts;\n    const ping = {\n        enabled: opts.ping?.enabled ?? false,\n        intervalMs: opts.ping?.intervalMs ?? 1000\n    };\n    run(async ()=>{\n        let iterable = opts.data;\n        iterable = withCancel(iterable, stream.cancelledPromise);\n        if (opts.emitAndEndImmediately) {\n            iterable = takeWithGrace(iterable, {\n                count: 1,\n                gracePeriodMs: 1,\n                onCancel: ()=>opts.abortCtrl.abort()\n            });\n        }\n        let maxDurationTimer = null;\n        if (opts.maxDurationMs != null && opts.maxDurationMs > 0 && opts.maxDurationMs !== Infinity) {\n            maxDurationTimer = createPromiseTimer(opts.maxDurationMs).start();\n            iterable = withCancel(iterable, maxDurationTimer.promise.then(()=>opts.abortCtrl.abort()));\n        }\n        if (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) {\n            iterable = withPing(iterable, ping.intervalMs);\n        }\n        try {\n            for await (const value of iterable){\n                if (value === PING_SYM) {\n                    stream.controller.enqueue({\n                        comment: 'ping'\n                    });\n                    continue;\n                }\n                const chunk = isTrackedEnvelope(value) ? {\n                    id: value[0],\n                    data: value[1]\n                } : {\n                    data: value\n                };\n                if ('data' in chunk) {\n                    chunk.data = JSON.stringify(serialize(chunk.data));\n                }\n                stream.controller.enqueue(chunk);\n            }\n        } catch (err) {\n            // ignore abort errors, send any other errors\n            if (!(err instanceof Error) || err.name !== 'AbortError') {\n                // `err` must be caused by `opts.data`, `JSON.stringify` or `serialize`.\n                // So, a user error in any case.\n                const error = getTRPCErrorFromUnknown(err);\n                const data = opts.formatError?.({\n                    error\n                }) ?? null;\n                stream.controller.enqueue({\n                    event: SERIALIZED_ERROR_EVENT,\n                    data: JSON.stringify(serialize(data))\n                });\n            }\n        } finally{\n            maxDurationTimer?.clear();\n            stream.controller.close();\n        }\n    }).catch((err)=>{\n        // should not be reached; just in case...\n        stream.controller.error(err);\n    });\n    return stream.readable.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if ('event' in chunk) {\n                controller.enqueue(`event: ${chunk.event}\\n`);\n            }\n            if ('data' in chunk) {\n                controller.enqueue(`data: ${chunk.data}\\n`);\n            }\n            if ('id' in chunk) {\n                controller.enqueue(`id: ${chunk.id}\\n`);\n            }\n            if ('comment' in chunk) {\n                controller.enqueue(`: ${chunk.comment}\\n`);\n            }\n            controller.enqueue('\\n\\n');\n        }\n    }));\n}\n/**\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */ function sseStreamConsumer(opts) {\n    const { deserialize =(v)=>v , shouldRecreateOnError  } = opts;\n    const signal = opts.signal;\n    let eventSource = null;\n    let lock = null;\n    const stream = createReadableStream();\n    function createEventSource(...args) {\n        const es = new EventSource(...args);\n        if (signal.aborted) {\n            es.close();\n        } else {\n            signal.addEventListener('abort', ()=>es.close());\n        }\n        /**\n     * Dispatch an event to the stream controller\n     *\n     * Will be a no-op if the event source has been replaced\n     */ const dispatch = (fn)=>{\n            run(async ()=>{\n                while(lock){\n                    await lock;\n                }\n                if (es === eventSource) {\n                    await fn(stream.controller);\n                }\n            }).catch((error)=>{\n                stream.controller.error(error);\n            });\n        };\n        const pauseDispatch = async (fn)=>{\n            while(lock){\n                await lock;\n            }\n            if (es !== eventSource) {\n                return;\n            }\n            const deferred = createDeferred();\n            lock = deferred.promise;\n            try {\n                await fn();\n            } finally{\n                lock = null;\n                deferred.resolve();\n            }\n        };\n        es.addEventListener('open', ()=>{\n            dispatch((controller)=>{\n                controller.enqueue({\n                    type: 'opened',\n                    eventSource: es\n                });\n            });\n        });\n        es.addEventListener(SERIALIZED_ERROR_EVENT, (msg)=>{\n            dispatch(async ()=>{\n                if (shouldRecreateOnError) {\n                    await pauseDispatch(async ()=>{\n                        const recreate = await shouldRecreateOnError({\n                            type: SERIALIZED_ERROR_EVENT,\n                            error: deserialize(JSON.parse(msg.data))\n                        });\n                        if (recreate) {\n                            await recreateEventSource();\n                        }\n                    });\n                }\n                dispatch((controller)=>{\n                    controller.enqueue({\n                        type: 'error',\n                        error: deserialize(JSON.parse(msg.data)),\n                        eventSource: es\n                    });\n                });\n            });\n        });\n        es.addEventListener('error', (event)=>{\n            dispatch(async ()=>{\n                if (shouldRecreateOnError) {\n                    await pauseDispatch(async ()=>{\n                        const recreate = await shouldRecreateOnError({\n                            type: 'event',\n                            event\n                        });\n                        if (recreate) {\n                            await recreateEventSource();\n                        }\n                    });\n                }\n                dispatch((controller)=>{\n                    if (es.readyState === EventSource.CLOSED) {\n                        controller.error(event);\n                    } else {\n                        controller.enqueue({\n                            type: 'connecting',\n                            eventSource: es\n                        });\n                    }\n                });\n            });\n        });\n        es.addEventListener('message', (msg)=>{\n            dispatch((controller)=>{\n                const chunk = deserialize(JSON.parse(msg.data));\n                const def = {\n                    data: chunk\n                };\n                if (msg.lastEventId) {\n                    def.id = msg.lastEventId;\n                }\n                controller.enqueue({\n                    type: 'data',\n                    data: def,\n                    eventSource: es\n                });\n            });\n        });\n        return es;\n    }\n    async function recreateEventSource() {\n        eventSource?.close();\n        const [url, init] = await Promise.all([\n            opts.url(),\n            opts.init()\n        ]);\n        eventSource = createEventSource(url, init);\n        stream.controller.enqueue({\n            type: 'connecting',\n            eventSource\n        });\n    }\n    recreateEventSource().catch(()=>{\n    // prevent unhandled promise rejection\n    });\n    return {\n        [Symbol.asyncIterator] () {\n            const reader = stream.readable.getReader();\n            const iterator = {\n                async next () {\n                    const value = await reader.read();\n                    if (value.done) {\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                    return {\n                        value: value.value,\n                        done: false\n                    };\n                },\n                async return () {\n                    reader.releaseLock();\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n            };\n            return iterator;\n        }\n    };\n}\nconst sseHeaders = {\n    'Content-Type': 'text/event-stream',\n    'Cache-Control': 'no-cache, no-transform',\n    'X-Accel-Buffering': 'no',\n    Connection: 'keep-alive'\n};\n\nexport { sseHeaders, sseStreamConsumer, sseStreamProducer };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2204, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2209, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/transformer.mjs"],"sourcesContent":["import { isObject } from './utils.mjs';\n\n/**\n * @internal\n */ function getDataTransformer(transformer) {\n    if ('input' in transformer) {\n        return transformer;\n    }\n    return {\n        input: transformer,\n        output: transformer\n    };\n}\n/**\n * @internal\n */ const defaultTransformer = {\n    input: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    },\n    output: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    }\n};\nfunction transformTRPCResponseItem(config, item) {\n    if ('error' in item) {\n        return {\n            ...item,\n            error: config.transformer.output.serialize(item.error)\n        };\n    }\n    if ('data' in item.result) {\n        return {\n            ...item,\n            result: {\n                ...item.result,\n                data: config.transformer.output.serialize(item.result.data)\n            }\n        };\n    }\n    return item;\n}\n/**\n * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n **/ function transformTRPCResponse(config, itemOrItems) {\n    return Array.isArray(itemOrItems) ? itemOrItems.map((item)=>transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);\n}\n// FIXME:\n// - the generics here are probably unnecessary\n// - the RPC-spec could probably be simplified to combine HTTP + WS\n/** @internal */ function transformResultInner(response, transformer) {\n    if ('error' in response) {\n        const error = transformer.deserialize(response.error);\n        return {\n            ok: false,\n            error: {\n                ...response,\n                error\n            }\n        };\n    }\n    const result = {\n        ...response.result,\n        ...(!response.result.type || response.result.type === 'data') && {\n            type: 'data',\n            data: transformer.deserialize(response.result.data)\n        }\n    };\n    return {\n        ok: true,\n        result\n    };\n}\nclass TransformResultError extends Error {\n    constructor(){\n        super('Unable to transform response from server');\n    }\n}\n/**\n * Transforms and validates that the result is a valid TRPCResponse\n * @internal\n */ function transformResult(response, transformer) {\n    let result;\n    try {\n        // Use the data transformers on the JSON-response\n        result = transformResultInner(response, transformer);\n    } catch (err) {\n        throw new TransformResultError();\n    }\n    // check that output of the transformers is a valid TRPCResponse\n    if (!result.ok && (!isObject(result.error.error) || typeof result.error.error['code'] !== 'number')) {\n        throw new TransformResultError();\n    }\n    if (result.ok && !isObject(result.result)) {\n        throw new TransformResultError();\n    }\n    return result;\n}\n\nexport { defaultTransformer, getDataTransformer, transformResult, transformTRPCResponse };\n"],"names":[],"mappings":";;;;;;;;;AAEA;;CAEC,GAAG,SAAS,mBAAmB,WAAW;IACvC,IAAI,WAAW,aAAa;QACxB,OAAO;IACX;IACA,OAAO;QACH,OAAO;QACP,QAAQ;IACZ;AACJ;AACA;;CAEC,GAAG,MAAM,qBAAqB;IAC3B,OAAO;QACH,WAAW,CAAC,MAAM;QAClB,aAAa,CAAC,MAAM;IACxB;IACA,QAAQ;QACJ,WAAW,CAAC,MAAM;QAClB,aAAa,CAAC,MAAM;IACxB;AACJ;AACA,SAAS,0BAA0B,MAAM,EAAE,IAAI;IAC3C,IAAI,WAAW,MAAM;QACjB,OAAO;YACH,GAAG,IAAI;YACP,OAAO,OAAO,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,KAAK;QACzD;IACJ;IACA,IAAI,UAAU,KAAK,MAAM,EAAE;QACvB,OAAO;YACH,GAAG,IAAI;YACP,QAAQ;gBACJ,GAAG,KAAK,MAAM;gBACd,MAAM,OAAO,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,MAAM,CAAC,IAAI;YAC9D;QACJ;IACJ;IACA,OAAO;AACX;AACA;;EAEE,GAAG,SAAS,sBAAsB,MAAM,EAAE,WAAW;IACnD,OAAO,MAAM,OAAO,CAAC,eAAe,YAAY,GAAG,CAAC,CAAC,OAAO,0BAA0B,QAAQ,SAAS,0BAA0B,QAAQ;AAC7I;AACA,SAAS;AACT,+CAA+C;AAC/C,mEAAmE;AACnE,cAAc,GAAG,SAAS,qBAAqB,QAAQ,EAAE,WAAW;IAChE,IAAI,WAAW,UAAU;QACrB,MAAM,QAAQ,YAAY,WAAW,CAAC,SAAS,KAAK;QACpD,OAAO;YACH,IAAI;YACJ,OAAO;gBACH,GAAG,QAAQ;gBACX;YACJ;QACJ;IACJ;IACA,MAAM,SAAS;QACX,GAAG,SAAS,MAAM;QAClB,GAAG,CAAC,CAAC,SAAS,MAAM,CAAC,IAAI,IAAI,SAAS,MAAM,CAAC,IAAI,KAAK,MAAM,KAAK;YAC7D,MAAM;YACN,MAAM,YAAY,WAAW,CAAC,SAAS,MAAM,CAAC,IAAI;QACtD,CAAC;IACL;IACA,OAAO;QACH,IAAI;QACJ;IACJ;AACJ;AACA,MAAM,6BAA6B;IAC/B,aAAa;QACT,KAAK,CAAC;IACV;AACJ;AACA;;;CAGC,GAAG,SAAS,gBAAgB,QAAQ,EAAE,WAAW;IAC9C,IAAI;IACJ,IAAI;QACA,iDAAiD;QACjD,SAAS,qBAAqB,UAAU;IAC5C,EAAE,OAAO,KAAK;QACV,MAAM,IAAI;IACd;IACA,gEAAgE;IAChE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAA,GAAA,6LAAA,CAAA,WAAQ,AAAD,EAAE,OAAO,KAAK,CAAC,KAAK,KAAK,OAAO,OAAO,KAAK,CAAC,KAAK,CAAC,OAAO,KAAK,QAAQ,GAAG;QACjG,MAAM,IAAI;IACd;IACA,IAAI,OAAO,EAAE,IAAI,CAAC,CAAA,GAAA,6LAAA,CAAA,WAAQ,AAAD,EAAE,OAAO,MAAM,GAAG;QACvC,MAAM,IAAI;IACd;IACA,OAAO;AACX"}},
    {"offset": {"line": 2316, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2321, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/http/resolveResponse.mjs"],"sourcesContent":["import { isObservable, observableToAsyncIterable } from '../../observable/observable.mjs';\nimport { getErrorShape } from '../error/getErrorShape.mjs';\nimport { TRPCError, getTRPCErrorFromUnknown } from '../error/TRPCError.mjs';\nimport { jsonlStreamProducer, isPromise } from '../stream/jsonl.mjs';\nimport { sseStreamProducer, sseHeaders } from '../stream/sse.mjs';\nimport { transformTRPCResponse } from '../transformer.mjs';\nimport { abortSignalsAnyPonyfill, assert, isAsyncIterable, isObject } from '../utils.mjs';\nimport { getRequestInfo } from './contentType.mjs';\nimport { getHTTPStatusCode } from './getHTTPStatusCode.mjs';\n\nconst TYPE_ACCEPTED_METHOD_MAP = {\n    mutation: [\n        'POST'\n    ],\n    query: [\n        'GET'\n    ],\n    subscription: [\n        'GET'\n    ]\n};\nconst TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE = {\n    // never allow GET to do a mutation\n    mutation: [\n        'POST'\n    ],\n    query: [\n        'GET',\n        'POST'\n    ],\n    subscription: [\n        'GET',\n        'POST'\n    ]\n};\nfunction initResponse(initOpts) {\n    const { ctx , info , responseMeta , untransformedJSON , errors =[] , headers ,  } = initOpts;\n    let status = untransformedJSON ? getHTTPStatusCode(untransformedJSON) : 200;\n    const eagerGeneration = !untransformedJSON;\n    const data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [\n        untransformedJSON\n    ];\n    const meta = responseMeta?.({\n        ctx,\n        info,\n        paths: info?.calls.map((call)=>call.path),\n        data,\n        errors,\n        eagerGeneration,\n        type: info?.calls.find((call)=>call.procedure?._def.type)?.procedure?._def.type ?? 'unknown'\n    }) ?? {};\n    if (meta.headers) {\n        if (meta.headers instanceof Headers) {\n            for (const [key, value] of meta.headers.entries()){\n                headers.append(key, value);\n            }\n        } else {\n            /**\n       * @deprecated, delete in v12\n       */ for (const [key1, value1] of Object.entries(meta.headers)){\n                if (Array.isArray(value1)) {\n                    for (const v of value1){\n                        headers.append(key1, v);\n                    }\n                } else if (typeof value1 === 'string') {\n                    headers.set(key1, value1);\n                }\n            }\n        }\n    }\n    if (meta.status) {\n        status = meta.status;\n    }\n    return {\n        status\n    };\n}\nfunction caughtErrorToData(cause, errorOpts) {\n    const { router , req , onError  } = errorOpts.opts;\n    const error = getTRPCErrorFromUnknown(cause);\n    onError?.({\n        error,\n        path: errorOpts.path,\n        input: errorOpts.input,\n        ctx: errorOpts.ctx,\n        type: errorOpts.type,\n        req\n    });\n    const untransformedJSON = {\n        error: getErrorShape({\n            config: router._def._config,\n            error,\n            type: errorOpts.type,\n            path: errorOpts.path,\n            input: errorOpts.input,\n            ctx: errorOpts.ctx\n        })\n    };\n    const transformedJSON = transformTRPCResponse(router._def._config, untransformedJSON);\n    const body = JSON.stringify(transformedJSON);\n    return {\n        error,\n        untransformedJSON,\n        body\n    };\n}\n/**\n * Check if a value is a stream-like object\n * - if it's an async iterable\n * - if it's an object with async iterables or promises\n */ function isDataStream(v) {\n    if (!isObject(v)) {\n        return false;\n    }\n    if (isAsyncIterable(v)) {\n        return true;\n    }\n    return Object.values(v).some(isPromise) || Object.values(v).some(isAsyncIterable);\n}\nasync function resolveResponse(opts) {\n    const { router , req  } = opts;\n    const headers = new Headers([\n        [\n            'vary',\n            'trpc-accept'\n        ]\n    ]);\n    const config = router._def._config;\n    const url = new URL(req.url);\n    if (req.method === 'HEAD') {\n        // can be used for lambda warmup\n        return new Response(null, {\n            status: 204\n        });\n    }\n    const allowBatching = opts.allowBatching ?? opts.batching?.enabled ?? true;\n    const allowMethodOverride = (opts.allowMethodOverride ?? false) && req.method === 'POST';\n    let ctx = undefined;\n    let info = undefined;\n    const methodMapper = allowMethodOverride ? TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE : TYPE_ACCEPTED_METHOD_MAP;\n    /**\n   * @deprecated\n   */ const isStreamCall = req.headers.get('trpc-accept') === 'application/jsonl';\n    const experimentalIterablesAndDeferreds = router._def._config.experimental?.iterablesAndDeferreds ?? true;\n    const experimentalSSE = router._def._config.experimental?.sseSubscriptions?.enabled ?? true;\n    try {\n        info = getRequestInfo({\n            req,\n            path: decodeURIComponent(opts.path),\n            router,\n            searchParams: url.searchParams,\n            headers: opts.req.headers\n        });\n        // we create context early so that error handlers may access context information\n        ctx = await opts.createContext({\n            info\n        });\n        if (opts.error) {\n            throw opts.error;\n        }\n        if (info.isBatchCall && !allowBatching) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                message: `Batching is not enabled on the server`\n            });\n        }\n        /* istanbul ignore if -- @preserve */ if (isStreamCall && !info.isBatchCall) {\n            throw new TRPCError({\n                message: `Streaming requests must be batched (you can do a batch of 1)`,\n                code: 'BAD_REQUEST'\n            });\n        }\n        const rpcCalls = info.calls.map(async (call)=>{\n            const proc = call.procedure;\n            try {\n                if (!proc) {\n                    throw new TRPCError({\n                        code: 'NOT_FOUND',\n                        message: `No procedure found on path \"${call.path}\"`\n                    });\n                }\n                if (!methodMapper[proc._def.type].includes(req.method)) {\n                    throw new TRPCError({\n                        code: 'METHOD_NOT_SUPPORTED',\n                        message: `Unsupported ${req.method}-request to ${proc._def.type} procedure at path \"${call.path}\"`\n                    });\n                }\n                let abortCtrl;\n                if (proc._def.type === 'subscription') {\n                    /* istanbul ignore if -- @preserve */ if (info.isBatchCall) {\n                        throw new TRPCError({\n                            code: 'BAD_REQUEST',\n                            message: `Cannot batch subscription calls`\n                        });\n                    }\n                    abortCtrl = new AbortController();\n                }\n                const data = await proc({\n                    path: call.path,\n                    getRawInput: call.getRawInput,\n                    ctx,\n                    type: proc._def.type,\n                    signal: abortCtrl ? abortSignalsAnyPonyfill([\n                        opts.req.signal,\n                        abortCtrl.signal\n                    ]) : opts.req.signal\n                });\n                return [\n                    {\n                        data,\n                        abortCtrl\n                    }\n                ];\n            } catch (cause) {\n                const error = getTRPCErrorFromUnknown(cause);\n                const input = call.result();\n                opts.onError?.({\n                    error,\n                    path: call.path,\n                    input,\n                    ctx,\n                    type: call.procedure?._def.type ?? 'unknown',\n                    req: opts.req\n                });\n                return [\n                    null,\n                    error\n                ];\n            }\n        });\n        // ----------- response handlers -----------\n        if (!info.isBatchCall) {\n            const [call] = info.calls;\n            const [result, error] = await rpcCalls[0];\n            switch(info.type){\n                case 'unknown':\n                case 'mutation':\n                case 'query':\n                    {\n                        // httpLink\n                        headers.set('content-type', 'application/json');\n                        if (isDataStream(result?.data)) {\n                            throw new TRPCError({\n                                code: 'UNSUPPORTED_MEDIA_TYPE',\n                                message: 'Cannot use stream-like response in non-streaming request - use httpBatchStreamLink'\n                            });\n                        }\n                        const res = error ? {\n                            error: getErrorShape({\n                                config,\n                                ctx,\n                                error,\n                                input: call.result(),\n                                path: call.path,\n                                type: info.type\n                            })\n                        } : {\n                            result: {\n                                data: result.data\n                            }\n                        };\n                        const headResponse = initResponse({\n                            ctx,\n                            info,\n                            responseMeta: opts.responseMeta,\n                            errors: error ? [\n                                error\n                            ] : [],\n                            headers,\n                            untransformedJSON: [\n                                res\n                            ]\n                        });\n                        return new Response(JSON.stringify(transformTRPCResponse(config, res)), {\n                            status: headResponse.status,\n                            headers\n                        });\n                    }\n                case 'subscription':\n                    {\n                        // httpSubscriptionLink\n                        if (!experimentalSSE) {\n                            throw new TRPCError({\n                                code: 'METHOD_NOT_SUPPORTED',\n                                message: 'Missing experimental flag \"sseSubscriptions\"'\n                            });\n                        }\n                        if (error) {\n                            throw error;\n                        }\n                        const { data , abortCtrl  } = result;\n                        assert(abortCtrl !== undefined, 'subscription type must have an AbortController');\n                        if (!isObservable(data) && !isAsyncIterable(data)) {\n                            throw new TRPCError({\n                                message: `Subscription ${call.path} did not return an observable or a AsyncGenerator`,\n                                code: 'INTERNAL_SERVER_ERROR'\n                            });\n                        }\n                        const dataAsIterable = isObservable(data) ? observableToAsyncIterable(data) : data;\n                        const stream = sseStreamProducer({\n                            ...config.experimental?.sseSubscriptions,\n                            data: dataAsIterable,\n                            abortCtrl,\n                            serialize: (v)=>config.transformer.output.serialize(v),\n                            formatError (errorOpts) {\n                                const error = getTRPCErrorFromUnknown(errorOpts.error);\n                                const input = call?.result();\n                                const path = call?.path;\n                                const type = call?.procedure?._def.type ?? 'unknown';\n                                const shape = getErrorShape({\n                                    config,\n                                    ctx,\n                                    error,\n                                    input,\n                                    path,\n                                    type\n                                });\n                                opts.onError?.({\n                                    error,\n                                    path,\n                                    input,\n                                    ctx,\n                                    req: opts.req,\n                                    type\n                                });\n                                return shape;\n                            }\n                        });\n                        for (const [key, value] of Object.entries(sseHeaders)){\n                            headers.set(key, value);\n                        }\n                        const headResponse1 = initResponse({\n                            ctx,\n                            info,\n                            responseMeta: opts.responseMeta,\n                            errors: [],\n                            headers,\n                            untransformedJSON: null\n                        });\n                        return new Response(stream, {\n                            headers,\n                            status: headResponse1.status\n                        });\n                    }\n            }\n        }\n        // batch response handlers\n        if (info.accept === 'application/jsonl') {\n            // httpBatchStreamLink\n            headers.set('content-type', 'application/json');\n            headers.set('transfer-encoding', 'chunked');\n            const headResponse2 = initResponse({\n                ctx,\n                info,\n                responseMeta: opts.responseMeta,\n                errors: [],\n                headers,\n                untransformedJSON: null\n            });\n            const stream1 = jsonlStreamProducer({\n                /**\n         * Example structure for `maxDepth: 4`:\n         * {\n         *   // 1\n         *   0: {\n         *     // 2\n         *     result: {\n         *       // 3\n         *       data: // 4\n         *     }\n         *   }\n         * }\n         */ maxDepth: experimentalIterablesAndDeferreds ? 4 : 3,\n                data: rpcCalls.map(async (res)=>{\n                    const [result, error] = await res;\n                    const call = info.calls[0];\n                    if (error) {\n                        return {\n                            error: getErrorShape({\n                                config,\n                                ctx,\n                                error,\n                                input: call.result(),\n                                path: call.path,\n                                type: call.procedure?._def.type ?? 'unknown'\n                            })\n                        };\n                    }\n                    const { data  } = result;\n                    /**\n           * Not very pretty, but we need to wrap nested data in promises\n           * Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n           */ const dataAsPromiseOrIterable = isObservable(data) ? observableToAsyncIterable(data) : Promise.resolve(data);\n                    return {\n                        result: Promise.resolve({\n                            data: dataAsPromiseOrIterable\n                        })\n                    };\n                }),\n                serialize: config.transformer.output.serialize,\n                onError: (cause)=>{\n                    opts.onError?.({\n                        error: getTRPCErrorFromUnknown(cause),\n                        path: undefined,\n                        input: undefined,\n                        ctx,\n                        req: opts.req,\n                        type: info?.type ?? 'unknown'\n                    });\n                },\n                formatError (errorOpts) {\n                    const call = info?.calls[errorOpts.path[0]];\n                    const shape = getErrorShape({\n                        config,\n                        ctx,\n                        error: getTRPCErrorFromUnknown(errorOpts.error),\n                        input: call?.result(),\n                        path: call?.path,\n                        type: call?.procedure?._def.type ?? 'unknown'\n                    });\n                    return shape;\n                }\n            });\n            return new Response(stream1, {\n                headers,\n                status: headResponse2.status\n            });\n        }\n        // httpBatchLink\n        /**\n     * Non-streaming response:\n     * - await all responses in parallel, blocking on the slowest one\n     * - create headers with known response body\n     * - return a complete HTTPResponse\n     */ headers.set('content-type', 'application/json');\n        const results = (await Promise.all(rpcCalls)).map((res)=>{\n            const [result, error] = res;\n            if (error) {\n                return res;\n            }\n            if (isDataStream(result.data)) {\n                return [\n                    null,\n                    new TRPCError({\n                        code: 'UNSUPPORTED_MEDIA_TYPE',\n                        message: 'Cannot use stream-like response in non-streaming request - use httpBatchStreamLink'\n                    })\n                ];\n            }\n            return res;\n        });\n        const resultAsRPCResponse = results.map(([result, error], index)=>{\n            const call = info.calls[index];\n            if (error) {\n                return {\n                    error: getErrorShape({\n                        config,\n                        ctx,\n                        error,\n                        input: call.result(),\n                        path: call.path,\n                        type: call.procedure?._def.type ?? 'unknown'\n                    })\n                };\n            }\n            return {\n                result: {\n                    data: result.data\n                }\n            };\n        });\n        const errors = results.map(([_, error])=>error).filter(Boolean);\n        const headResponse3 = initResponse({\n            ctx,\n            info,\n            responseMeta: opts.responseMeta,\n            untransformedJSON: resultAsRPCResponse,\n            errors,\n            headers\n        });\n        return new Response(JSON.stringify(transformTRPCResponse(config, resultAsRPCResponse)), {\n            status: headResponse3.status,\n            headers\n        });\n    } catch (cause) {\n        // we get here if\n        // - batching is called when it's not enabled\n        // - `createContext()` throws\n        // - `router._def._config.transformer.output.serialize()` throws\n        // - post body is too large\n        // - input deserialization fails\n        // - `errorFormatter` return value is malformed\n        const { error: error1 , untransformedJSON , body  } = caughtErrorToData(cause, {\n            opts,\n            ctx,\n            type: info?.type ?? 'unknown'\n        });\n        const headResponse4 = initResponse({\n            ctx,\n            info,\n            responseMeta: opts.responseMeta,\n            untransformedJSON,\n            errors: [\n                error1\n            ],\n            headers\n        });\n        return new Response(body, {\n            status: headResponse4.status,\n            headers\n        });\n    }\n}\n\nexport { resolveResponse };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2847, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2852, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/http/toURL.mjs"],"sourcesContent":["import { TRPCError } from '../error/TRPCError.mjs';\n\nfunction toURL(urlOrPathname) {\n    try {\n        const url = urlOrPathname.startsWith('/') ? `http://127.0.0.1${urlOrPathname}` : urlOrPathname;\n        return new URL(url);\n    } catch (cause) {\n        throw new TRPCError({\n            code: 'BAD_REQUEST',\n            message: 'Invalid URL',\n            cause\n        });\n    }\n}\n\nexport { toURL };\n"],"names":[],"mappings":";;;;;;AAEA,SAAS,MAAM,aAAa;IACxB,IAAI;QACA,MAAM,MAAM,cAAc,UAAU,CAAC,OAAO,CAAC,gBAAgB,EAAE,cAAc,CAAC,GAAG;QACjF,OAAO,IAAI,IAAI;IACnB,EAAE,OAAO,OAAO;QACZ,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;YAChB,MAAM;YACN,SAAS;YACT;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 2871, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2876, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/middleware.mjs"],"sourcesContent":["import { TRPCError } from './error/TRPCError.mjs';\nimport { isObject } from './utils.mjs';\n\n/** @internal */ const middlewareMarker = 'middlewareMarker';\n/**\n * @internal\n */ function createMiddlewareFactory() {\n    function createMiddlewareInner(middlewares) {\n        return {\n            _middlewares: middlewares,\n            unstable_pipe (middlewareBuilderOrFn) {\n                const pipedMiddleware = '_middlewares' in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                    middlewareBuilderOrFn\n                ];\n                return createMiddlewareInner([\n                    ...middlewares,\n                    ...pipedMiddleware\n                ]);\n            }\n        };\n    }\n    function createMiddleware(fn) {\n        return createMiddlewareInner([\n            fn\n        ]);\n    }\n    return createMiddleware;\n}\n/**\n * Create a standalone middleware\n * @see https://trpc.io/docs/v11/server/middlewares#experimental-standalone-middlewares\n * @deprecated use `.unstable_concat()` instead\n */ const experimental_standaloneMiddleware = ()=>({\n        create: createMiddlewareFactory()\n    });\n/**\n * @internal\n * Please note, `trpc-openapi` uses this function.\n */ function createInputMiddleware(parse) {\n    const inputMiddleware = async function inputValidatorMiddleware(opts) {\n        let parsedInput;\n        const rawInput = await opts.getRawInput();\n        try {\n            parsedInput = await parse(rawInput);\n        } catch (cause) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                cause\n            });\n        }\n        // Multiple input parsers\n        const combinedInput = isObject(opts.input) && isObject(parsedInput) ? {\n            ...opts.input,\n            ...parsedInput\n        } : parsedInput;\n        return opts.next({\n            input: combinedInput\n        });\n    };\n    inputMiddleware._type = 'input';\n    return inputMiddleware;\n}\n/**\n * @internal\n */ function createOutputMiddleware(parse) {\n    const outputMiddleware = async function outputValidatorMiddleware({ next  }) {\n        const result = await next();\n        if (!result.ok) {\n            // pass through failures without validating\n            return result;\n        }\n        try {\n            const data = await parse(result.data);\n            return {\n                ...result,\n                data\n            };\n        } catch (cause) {\n            throw new TRPCError({\n                message: 'Output validation failed',\n                code: 'INTERNAL_SERVER_ERROR',\n                cause\n            });\n        }\n    };\n    outputMiddleware._type = 'output';\n    return outputMiddleware;\n}\n\nexport { createInputMiddleware, createMiddlewareFactory, createOutputMiddleware, experimental_standaloneMiddleware, middlewareMarker };\n"],"names":[],"mappings":";;;;;;;;;;;;AAGA,cAAc,GAAG,MAAM,mBAAmB;AAC1C;;CAEC,GAAG,SAAS;IACT,SAAS,sBAAsB,WAAW;QACtC,OAAO;YACH,cAAc;YACd,eAAe,qBAAqB;gBAChC,MAAM,kBAAkB,kBAAkB,wBAAwB,sBAAsB,YAAY,GAAG;oBACnG;iBACH;gBACD,OAAO,sBAAsB;uBACtB;uBACA;iBACN;YACL;QACJ;IACJ;IACA,SAAS,iBAAiB,EAAE;QACxB,OAAO,sBAAsB;YACzB;SACH;IACL;IACA,OAAO;AACX;AACA;;;;CAIC,GAAG,MAAM,oCAAoC,IAAI,CAAC;QAC3C,QAAQ;IACZ,CAAC;AACL;;;CAGC,GAAG,SAAS,sBAAsB,KAAK;IACpC,MAAM,kBAAkB,eAAe,yBAAyB,IAAI;QAChE,IAAI;QACJ,MAAM,WAAW,MAAM,KAAK,WAAW;QACvC,IAAI;YACA,cAAc,MAAM,MAAM;QAC9B,EAAE,OAAO,OAAO;YACZ,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAChB,MAAM;gBACN;YACJ;QACJ;QACA,yBAAyB;QACzB,MAAM,gBAAgB,CAAA,GAAA,6LAAA,CAAA,WAAQ,AAAD,EAAE,KAAK,KAAK,KAAK,CAAA,GAAA,6LAAA,CAAA,WAAQ,AAAD,EAAE,eAAe;YAClE,GAAG,KAAK,KAAK;YACb,GAAG,WAAW;QAClB,IAAI;QACJ,OAAO,KAAK,IAAI,CAAC;YACb,OAAO;QACX;IACJ;IACA,gBAAgB,KAAK,GAAG;IACxB,OAAO;AACX;AACA;;CAEC,GAAG,SAAS,uBAAuB,KAAK;IACrC,MAAM,mBAAmB,eAAe,0BAA0B,EAAE,IAAI,EAAG;QACvE,MAAM,SAAS,MAAM;QACrB,IAAI,CAAC,OAAO,EAAE,EAAE;YACZ,2CAA2C;YAC3C,OAAO;QACX;QACA,IAAI;YACA,MAAM,OAAO,MAAM,MAAM,OAAO,IAAI;YACpC,OAAO;gBACH,GAAG,MAAM;gBACT;YACJ;QACJ,EAAE,OAAO,OAAO;YACZ,MAAM,IAAI,0MAAA,CAAA,YAAS,CAAC;gBAChB,SAAS;gBACT,MAAM;gBACN;YACJ;QACJ;IACJ;IACA,iBAAiB,KAAK,GAAG;IACzB,OAAO;AACX"}},
    {"offset": {"line": 2974, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2979, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/parser.mjs"],"sourcesContent":["// zod / typeschema\nfunction getParseFn(procedureParser) {\n    const parser = procedureParser;\n    if (typeof parser === 'function' && typeof parser.assert === 'function') {\n        // ParserArkTypeEsque - arktype schemas shouldn't be called as a function because they return a union type instead of throwing\n        return parser.assert.bind(parser);\n    }\n    if (typeof parser === 'function') {\n        // ParserValibotEsque (>= v0.31.0)\n        // ParserCustomValidatorEsque\n        return parser;\n    }\n    if (typeof parser.parseAsync === 'function') {\n        // ParserZodEsque\n        return parser.parseAsync.bind(parser);\n    }\n    if (typeof parser.parse === 'function') {\n        // ParserZodEsque\n        // ParserValibotEsque (< v0.13.0)\n        return parser.parse.bind(parser);\n    }\n    if (typeof parser.validateSync === 'function') {\n        // ParserYupEsque\n        return parser.validateSync.bind(parser);\n    }\n    if (typeof parser.create === 'function') {\n        // ParserSuperstructEsque\n        return parser.create.bind(parser);\n    }\n    if (typeof parser.assert === 'function') {\n        // ParserScaleEsque\n        return (value)=>{\n            parser.assert(value);\n            return value;\n        };\n    }\n    throw new Error('Could not find a validator fn');\n}\n\nexport { getParseFn };\n"],"names":[],"mappings":"AAAA,mBAAmB;;;;AACnB,SAAS,WAAW,eAAe;IAC/B,MAAM,SAAS;IACf,IAAI,OAAO,WAAW,cAAc,OAAO,OAAO,MAAM,KAAK,YAAY;QACrE,8HAA8H;QAC9H,OAAO,OAAO,MAAM,CAAC,IAAI,CAAC;IAC9B;IACA,IAAI,OAAO,WAAW,YAAY;QAC9B,kCAAkC;QAClC,6BAA6B;QAC7B,OAAO;IACX;IACA,IAAI,OAAO,OAAO,UAAU,KAAK,YAAY;QACzC,iBAAiB;QACjB,OAAO,OAAO,UAAU,CAAC,IAAI,CAAC;IAClC;IACA,IAAI,OAAO,OAAO,KAAK,KAAK,YAAY;QACpC,iBAAiB;QACjB,iCAAiC;QACjC,OAAO,OAAO,KAAK,CAAC,IAAI,CAAC;IAC7B;IACA,IAAI,OAAO,OAAO,YAAY,KAAK,YAAY;QAC3C,iBAAiB;QACjB,OAAO,OAAO,YAAY,CAAC,IAAI,CAAC;IACpC;IACA,IAAI,OAAO,OAAO,MAAM,KAAK,YAAY;QACrC,yBAAyB;QACzB,OAAO,OAAO,MAAM,CAAC,IAAI,CAAC;IAC9B;IACA,IAAI,OAAO,OAAO,MAAM,KAAK,YAAY;QACrC,mBAAmB;QACnB,OAAO,CAAC;YACJ,OAAO,MAAM,CAAC;YACd,OAAO;QACX;IACJ;IACA,MAAM,IAAI,MAAM;AACpB"}},
    {"offset": {"line": 3021, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3026, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/procedureBuilder.mjs"],"sourcesContent":["import { TRPCError, getTRPCErrorFromUnknown } from './error/TRPCError.mjs';\nimport { createInputMiddleware, createOutputMiddleware, middlewareMarker } from './middleware.mjs';\nimport { getParseFn } from './parser.mjs';\nimport { mergeWithoutOverrides } from './utils.mjs';\n\nfunction createNewBuilder(def1, def2) {\n    const { middlewares =[] , inputs , meta , ...rest } = def2;\n    // TODO: maybe have a fn here to warn about calls\n    return createBuilder({\n        ...mergeWithoutOverrides(def1, rest),\n        inputs: [\n            ...def1.inputs,\n            ...inputs ?? []\n        ],\n        middlewares: [\n            ...def1.middlewares,\n            ...middlewares\n        ],\n        meta: def1.meta && meta ? {\n            ...def1.meta,\n            ...meta\n        } : meta ?? def1.meta\n    });\n}\nfunction createBuilder(initDef = {}) {\n    const _def = {\n        procedure: true,\n        inputs: [],\n        middlewares: [],\n        ...initDef\n    };\n    const builder = {\n        _def,\n        input (input) {\n            const parser = getParseFn(input);\n            return createNewBuilder(_def, {\n                inputs: [\n                    input\n                ],\n                middlewares: [\n                    createInputMiddleware(parser)\n                ]\n            });\n        },\n        output (output) {\n            const parser = getParseFn(output);\n            return createNewBuilder(_def, {\n                output,\n                middlewares: [\n                    createOutputMiddleware(parser)\n                ]\n            });\n        },\n        meta (meta) {\n            return createNewBuilder(_def, {\n                meta\n            });\n        },\n        use (middlewareBuilderOrFn) {\n            // Distinguish between a middleware builder and a middleware function\n            const middlewares = '_middlewares' in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                middlewareBuilderOrFn\n            ];\n            return createNewBuilder(_def, {\n                middlewares: middlewares\n            });\n        },\n        unstable_concat (builder) {\n            return createNewBuilder(_def, builder._def);\n        },\n        query (resolver) {\n            return createResolver({\n                ..._def,\n                type: 'query'\n            }, resolver);\n        },\n        mutation (resolver) {\n            return createResolver({\n                ..._def,\n                type: 'mutation'\n            }, resolver);\n        },\n        subscription (resolver) {\n            return createResolver({\n                ..._def,\n                type: 'subscription'\n            }, resolver);\n        },\n        experimental_caller (caller) {\n            return createNewBuilder(_def, {\n                caller\n            });\n        }\n    };\n    return builder;\n}\nfunction createResolver(_defIn, resolver) {\n    const finalBuilder = createNewBuilder(_defIn, {\n        resolver,\n        middlewares: [\n            async function resolveMiddleware(opts) {\n                const data = await resolver(opts);\n                return {\n                    marker: middlewareMarker,\n                    ok: true,\n                    data,\n                    ctx: opts.ctx\n                };\n            }\n        ]\n    });\n    const _def = {\n        ...finalBuilder._def,\n        type: _defIn.type,\n        experimental_caller: Boolean(finalBuilder._def.caller),\n        meta: finalBuilder._def.meta,\n        $types: null\n    };\n    const invoke = createProcedureCaller(finalBuilder._def);\n    const callerOverride = finalBuilder._def.caller;\n    if (!callerOverride) {\n        return invoke;\n    }\n    const callerWrapper = async (...args)=>{\n        return await callerOverride({\n            args,\n            invoke,\n            _def: _def\n        });\n    };\n    callerWrapper._def = _def;\n    return callerWrapper;\n}\nconst codeblock = `\nThis is a client-only function.\nIf you want to call this function on the server, see https://trpc.io/docs/v11/server/server-side-calls\n`.trim();\n// run the middlewares recursively with the resolver as the last one\nasync function callRecursive(index, _def, opts) {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const middleware = _def.middlewares[index];\n        const result = await middleware({\n            ...opts,\n            meta: _def.meta,\n            input: opts.input,\n            next (_nextOpts) {\n                const nextOpts = _nextOpts;\n                return callRecursive(index + 1, _def, {\n                    ...opts,\n                    ctx: nextOpts?.ctx ? {\n                        ...opts.ctx,\n                        ...nextOpts.ctx\n                    } : opts.ctx,\n                    input: nextOpts && 'input' in nextOpts ? nextOpts.input : opts.input,\n                    getRawInput: nextOpts?.getRawInput ?? opts.getRawInput\n                });\n            }\n        });\n        return result;\n    } catch (cause) {\n        return {\n            ok: false,\n            error: getTRPCErrorFromUnknown(cause),\n            marker: middlewareMarker\n        };\n    }\n}\nfunction createProcedureCaller(_def) {\n    async function procedure(opts) {\n        // is direct server-side call\n        if (!opts || !('getRawInput' in opts)) {\n            throw new Error(codeblock);\n        }\n        // there's always at least one \"next\" since we wrap this.resolver in a middleware\n        const result = await callRecursive(0, _def, opts);\n        if (!result) {\n            throw new TRPCError({\n                code: 'INTERNAL_SERVER_ERROR',\n                message: 'No result from middlewares - did you forget to `return next()`?'\n            });\n        }\n        if (!result.ok) {\n            // re-throw original error\n            throw result.error;\n        }\n        return result.data;\n    }\n    procedure._def = _def;\n    // FIXME typecast shouldn't be needed - fixittt\n    return procedure;\n}\n\nexport { createBuilder };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3226, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3231, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/rootConfig.mjs"],"sourcesContent":["/**\n * The default check to see if we're in a server\n */ const isServerDefault = typeof window === 'undefined' || 'Deno' in window || // eslint-disable-next-line @typescript-eslint/dot-notation\nglobalThis.process?.env?.['NODE_ENV'] === 'test' || !!globalThis.process?.env?.['JEST_WORKER_ID'] || !!globalThis.process?.env?.['VITEST_WORKER_ID'];\n\nexport { isServerDefault };\n"],"names":[],"mappings":"AAAA;;CAEC;;;AAAG,MAAM,kBAAkB,OAAO,WAAW,eAAe,UAAU,UAAU,2DAA2D;AAC5I,WAAW,OAAO,EAAE,KAAK,CAAC,WAAW,KAAK,UAAU,CAAC,CAAC,WAAW,OAAO,EAAE,KAAK,CAAC,iBAAiB,IAAI,CAAC,CAAC,WAAW,OAAO,EAAE,KAAK,CAAC,mBAAmB"}},
    {"offset": {"line": 3239, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3244, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/router.mjs"],"sourcesContent":["import { createRecursiveProxy } from './createProxy.mjs';\nimport { defaultFormatter } from './error/formatter.mjs';\nimport { TRPCError, getTRPCErrorFromUnknown } from './error/TRPCError.mjs';\nimport { defaultTransformer } from './transformer.mjs';\nimport { mergeWithoutOverrides, omitPrototype, isFunction } from './utils.mjs';\n\nfunction isRouter(procedureOrRouter) {\n    return procedureOrRouter._def && 'router' in procedureOrRouter._def;\n}\nconst emptyRouter = {\n    _ctx: null,\n    _errorShape: null,\n    _meta: null,\n    queries: {},\n    mutations: {},\n    subscriptions: {},\n    errorFormatter: defaultFormatter,\n    transformer: defaultTransformer\n};\n/**\n * Reserved words that can't be used as router or procedure names\n */ const reservedWords = [\n    /**\n   * Then is a reserved word because otherwise we can't return a promise that returns a Proxy\n   * since JS will think that `.then` is something that exists\n   */ 'then',\n    /**\n   * `fn.call()` and `fn.apply()` are reserved words because otherwise we can't call a function using `.call` or `.apply`\n   */ 'call',\n    'apply'\n];\n/**\n * @internal\n */ function createRouterFactory(config) {\n    function createRouterInner(input) {\n        const reservedWordsUsed = new Set(Object.keys(input).filter((v)=>reservedWords.includes(v)));\n        if (reservedWordsUsed.size > 0) {\n            throw new Error('Reserved words used in `router({})` call: ' + Array.from(reservedWordsUsed).join(', '));\n        }\n        const procedures = omitPrototype({});\n        function step(from, path = []) {\n            const aggregate = omitPrototype({});\n            for (const [key, item] of Object.entries(from ?? {})){\n                if (isRouter(item)) {\n                    aggregate[key] = step(item._def.record, [\n                        ...path,\n                        key\n                    ]);\n                    continue;\n                }\n                if (!isProcedure(item)) {\n                    // RouterRecord\n                    aggregate[key] = step(item, [\n                        ...path,\n                        key\n                    ]);\n                    continue;\n                }\n                const newPath = [\n                    ...path,\n                    key\n                ].join('.');\n                if (procedures[newPath]) {\n                    throw new Error(`Duplicate key: ${newPath}`);\n                }\n                procedures[newPath] = item;\n                aggregate[key] = item;\n            }\n            return aggregate;\n        }\n        const record = step(input);\n        const _def = {\n            _config: config,\n            router: true,\n            procedures,\n            ...emptyRouter,\n            record\n        };\n        return {\n            ...record,\n            _def,\n            createCaller: createCallerFactory()({\n                _def\n            })\n        };\n    }\n    return createRouterInner;\n}\nfunction isProcedure(procedureOrRouter) {\n    return typeof procedureOrRouter === 'function';\n}\n/**\n * @internal\n */ function callProcedure(opts) {\n    const { type , path  } = opts;\n    const proc = opts.procedures[path];\n    if (!proc || !isProcedure(proc) || proc._def.type !== type && !opts.allowMethodOverride) {\n        throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `No \"${type}\"-procedure on path \"${path}\"`\n        });\n    }\n    /* istanbul ignore if -- @preserve */ if (proc._def.type !== type && opts.allowMethodOverride && proc._def.type === 'subscription') {\n        throw new TRPCError({\n            code: 'METHOD_NOT_SUPPORTED',\n            message: `Method override is not supported for subscriptions`\n        });\n    }\n    return proc(opts);\n}\nfunction createCallerFactory() {\n    return function createCallerInner(router) {\n        const _def = router._def;\n        return function createCaller(ctxOrCallback, opts) {\n            return createRecursiveProxy(async ({ path , args  })=>{\n                const fullPath = path.join('.');\n                if (path.length === 1 && path[0] === '_def') {\n                    return _def;\n                }\n                const procedure = _def.procedures[fullPath];\n                let ctx = undefined;\n                try {\n                    ctx = isFunction(ctxOrCallback) ? await Promise.resolve(ctxOrCallback()) : ctxOrCallback;\n                    return await procedure({\n                        path: fullPath,\n                        getRawInput: async ()=>args[0],\n                        ctx,\n                        type: procedure._def.type,\n                        signal: opts?.signal\n                    });\n                } catch (cause) {\n                    opts?.onError?.({\n                        ctx,\n                        error: getTRPCErrorFromUnknown(cause),\n                        input: args[0],\n                        path: fullPath,\n                        type: procedure._def.type\n                    });\n                    throw cause;\n                }\n            });\n        };\n    };\n}\nfunction mergeRouters(...routerList) {\n    const record = mergeWithoutOverrides({}, ...routerList.map((r)=>r._def.record));\n    const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter)=>{\n        if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {\n            if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {\n                throw new Error('You seem to have several error formatters');\n            }\n            return nextRouter._def._config.errorFormatter;\n        }\n        return currentErrorFormatter;\n    }, defaultFormatter);\n    const transformer = routerList.reduce((prev, current)=>{\n        if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {\n            if (prev !== defaultTransformer && prev !== current._def._config.transformer) {\n                throw new Error('You seem to have several transformers');\n            }\n            return current._def._config.transformer;\n        }\n        return prev;\n    }, defaultTransformer);\n    const router = createRouterFactory({\n        errorFormatter,\n        transformer,\n        isDev: routerList.every((r)=>r._def._config.isDev),\n        allowOutsideOfServer: routerList.every((r)=>r._def._config.allowOutsideOfServer),\n        isServer: routerList.every((r)=>r._def._config.isServer),\n        $types: routerList[0]?._def._config.$types\n    })(record);\n    return router;\n}\n\nexport { callProcedure, createCallerFactory, createRouterFactory, mergeRouters };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3430, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3435, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/initTRPC.mjs"],"sourcesContent":["import { defaultFormatter } from './error/formatter.mjs';\nimport { createMiddlewareFactory } from './middleware.mjs';\nimport { createBuilder } from './procedureBuilder.mjs';\nimport { isServerDefault } from './rootConfig.mjs';\nimport { createRouterFactory, mergeRouters, createCallerFactory } from './router.mjs';\nimport { getDataTransformer, defaultTransformer } from './transformer.mjs';\n\nclass TRPCBuilder {\n    /**\n   * Add a context shape as a generic to the root object\n   * @see https://trpc.io/docs/v11/server/context\n   */ context() {\n        return new TRPCBuilder();\n    }\n    /**\n   * Add a meta shape as a generic to the root object\n   * @see https://trpc.io/docs/v11/quickstart\n   */ meta() {\n        return new TRPCBuilder();\n    }\n    /**\n   * Create the root object\n   * @see https://trpc.io/docs/v11/server/routers#initialize-trpc\n   */ create(opts) {\n        const config = {\n            transformer: getDataTransformer(opts?.transformer ?? defaultTransformer),\n            isDev: opts?.isDev ?? // eslint-disable-next-line @typescript-eslint/dot-notation\n            globalThis.process?.env['NODE_ENV'] !== 'production',\n            allowOutsideOfServer: opts?.allowOutsideOfServer ?? false,\n            errorFormatter: opts?.errorFormatter ?? defaultFormatter,\n            isServer: opts?.isServer ?? isServerDefault,\n            /**\n       * These are just types, they can't be used at runtime\n       * @internal\n       */ $types: null,\n            experimental: opts?.experimental ?? {}\n        };\n        {\n            // Server check\n            const isServer = opts?.isServer ?? isServerDefault;\n            if (!isServer && opts?.allowOutsideOfServer !== true) {\n                throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);\n            }\n        }\n        return {\n            /**\n       * Your router config\n       * @internal\n       */ _config: config,\n            /**\n       * Builder object for creating procedures\n       * @see https://trpc.io/docs/v11/server/procedures\n       */ procedure: createBuilder({\n                meta: opts?.defaultMeta\n            }),\n            /**\n       * Create reusable middlewares\n       * @see https://trpc.io/docs/v11/server/middlewares\n       */ middleware: createMiddlewareFactory(),\n            /**\n       * Create a router\n       * @see https://trpc.io/docs/v11/server/routers\n       */ router: createRouterFactory(config),\n            /**\n       * Merge Routers\n       * @see https://trpc.io/docs/v11/server/merging-routers\n       */ mergeRouters,\n            /**\n       * Create a server-side caller for a router\n       * @see https://trpc.io/docs/v11/server/server-side-calls\n       */ createCallerFactory: createCallerFactory()\n        };\n    }\n}\n/**\n * Builder to initialize the tRPC root object - use this exactly once per backend\n * @see https://trpc.io/docs/v11/quickstart\n */ const initTRPC = new TRPCBuilder();\n\nexport { initTRPC };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAOA,MAAM;IACF;;;GAGD,GAAG,UAAU;QACR,OAAO,IAAI;IACf;IACA;;;GAGD,GAAG,OAAO;QACL,OAAO,IAAI;IACf;IACA;;;GAGD,GAAG,OAAO,IAAI,EAAE;QACX,MAAM,SAAS;YACX,aAAa,CAAA,GAAA,mMAAA,CAAA,qBAAkB,AAAD,EAAE,MAAM,eAAe,mMAAA,CAAA,qBAAkB;YACvE,OAAO,MAAM,SAAS,2DAA2D;YACjF,WAAW,OAAO,EAAE,GAAG,CAAC,WAAW,KAAK;YACxC,sBAAsB,MAAM,wBAAwB;YACpD,gBAAgB,MAAM,kBAAkB,0MAAA,CAAA,mBAAgB;YACxD,UAAU,MAAM,YAAY,kMAAA,CAAA,kBAAe;YAC3C;;;OAGL,GAAG,QAAQ;YACN,cAAc,MAAM,gBAAgB,CAAC;QACzC;QACA;YACI,eAAe;YACf,MAAM,WAAW,MAAM,YAAY,kMAAA,CAAA,kBAAe;YAClD,IAAI,CAAC,YAAY,MAAM,yBAAyB,MAAM;gBAClD,MAAM,IAAI,MAAM,CAAC,gGAAgG,CAAC;YACtH;QACJ;QACA,OAAO;YACH;;;OAGL,GAAG,SAAS;YACP;;;OAGL,GAAG,WAAW,CAAA,GAAA,wMAAA,CAAA,gBAAa,AAAD,EAAE;gBACnB,MAAM,MAAM;YAChB;YACA;;;OAGL,GAAG,YAAY,CAAA,GAAA,kMAAA,CAAA,0BAAuB,AAAD;YAChC;;;OAGL,GAAG,QAAQ,CAAA,GAAA,8LAAA,CAAA,sBAAmB,AAAD,EAAE;YAC1B;;;OAGL,GAAG,cAAA,8LAAA,CAAA,eAAY;YACV;;;OAGL,GAAG,qBAAqB,CAAA,GAAA,8LAAA,CAAA,sBAAmB,AAAD;QACzC;IACJ;AACJ;AACA;;;CAGC,GAAG,MAAM,WAAW,IAAI"}},
    {"offset": {"line": 3523, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3528, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/procedure.mjs"],"sourcesContent":["const procedureTypes = [\n    'query',\n    'mutation',\n    'subscription'\n];\n\nexport { procedureTypes };\n"],"names":[],"mappings":";;;AAAA,MAAM,iBAAiB;IACnB;IACA;IACA;CACH"}},
    {"offset": {"line": 3537, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3542, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@trpc/server/dist/unstable-core-do-not-import/rpc/parseTRPCMessage.mjs"],"sourcesContent":["import { procedureTypes } from '../procedure.mjs';\nimport { isObject } from '../utils.mjs';\n\n/* istanbul ignore next -- @preserve */ function assertIsObject(obj) {\n    if (!isObject(obj)) {\n        throw new Error('Not an object');\n    }\n}\n/* istanbul ignore next -- @preserve */ function assertIsProcedureType(obj) {\n    if (!procedureTypes.includes(obj)) {\n        throw new Error('Invalid procedure type');\n    }\n}\n/* istanbul ignore next -- @preserve */ function assertIsRequestId(obj) {\n    if (obj !== null && typeof obj === 'number' && isNaN(obj) && typeof obj !== 'string') {\n        throw new Error('Invalid request id');\n    }\n}\n/* istanbul ignore next -- @preserve */ function assertIsString(obj) {\n    if (typeof obj !== 'string') {\n        throw new Error('Invalid string');\n    }\n}\n/* istanbul ignore next -- @preserve */ function assertIsJSONRPC2OrUndefined(obj) {\n    if (typeof obj !== 'undefined' && obj !== '2.0') {\n        throw new Error('Must be JSONRPC 2.0');\n    }\n}\n/** @public */ function parseTRPCMessage(obj, transformer) {\n    assertIsObject(obj);\n    const { id , jsonrpc , method , params  } = obj;\n    assertIsRequestId(id);\n    assertIsJSONRPC2OrUndefined(jsonrpc);\n    if (method === 'subscription.stop') {\n        return {\n            id,\n            jsonrpc,\n            method\n        };\n    }\n    assertIsProcedureType(method);\n    assertIsObject(params);\n    const { input: rawInput , path , lastEventId  } = params;\n    assertIsString(path);\n    if (lastEventId !== undefined) {\n        assertIsString(lastEventId);\n    }\n    const input = transformer.input.deserialize(rawInput);\n    return {\n        id,\n        jsonrpc,\n        method,\n        params: {\n            input,\n            path,\n            lastEventId\n        }\n    };\n}\n\nexport { parseTRPCMessage };\n"],"names":[],"mappings":";;;;;;;;AAGA,qCAAqC,GAAG,SAAS,eAAe,GAAG;IAC/D,IAAI,CAAC,CAAA,GAAA,6LAAA,CAAA,WAAQ,AAAD,EAAE,MAAM;QAChB,MAAM,IAAI,MAAM;IACpB;AACJ;AACA,qCAAqC,GAAG,SAAS,sBAAsB,GAAG;IACtE,IAAI,CAAC,iMAAA,CAAA,iBAAc,CAAC,QAAQ,CAAC,MAAM;QAC/B,MAAM,IAAI,MAAM;IACpB;AACJ;AACA,qCAAqC,GAAG,SAAS,kBAAkB,GAAG;IAClE,IAAI,QAAQ,QAAQ,OAAO,QAAQ,YAAY,MAAM,QAAQ,OAAO,QAAQ,UAAU;QAClF,MAAM,IAAI,MAAM;IACpB;AACJ;AACA,qCAAqC,GAAG,SAAS,eAAe,GAAG;IAC/D,IAAI,OAAO,QAAQ,UAAU;QACzB,MAAM,IAAI,MAAM;IACpB;AACJ;AACA,qCAAqC,GAAG,SAAS,4BAA4B,GAAG;IAC5E,IAAI,OAAO,QAAQ,eAAe,QAAQ,OAAO;QAC7C,MAAM,IAAI,MAAM;IACpB;AACJ;AACA,YAAY,GAAG,SAAS,iBAAiB,GAAG,EAAE,WAAW;IACrD,eAAe;IACf,MAAM,EAAE,EAAE,EAAG,OAAO,EAAG,MAAM,EAAG,MAAM,EAAG,GAAG;IAC5C,kBAAkB;IAClB,4BAA4B;IAC5B,IAAI,WAAW,qBAAqB;QAChC,OAAO;YACH;YACA;YACA;QACJ;IACJ;IACA,sBAAsB;IACtB,eAAe;IACf,MAAM,EAAE,OAAO,QAAQ,EAAG,IAAI,EAAG,WAAW,EAAG,GAAG;IAClD,eAAe;IACf,IAAI,gBAAgB,WAAW;QAC3B,eAAe;IACnB;IACA,MAAM,QAAQ,YAAY,KAAK,CAAC,WAAW,CAAC;IAC5C,OAAO;QACH;QACA;QACA;QACA,QAAQ;YACJ;YACA;YACA;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 3607, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3612, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 3640, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}
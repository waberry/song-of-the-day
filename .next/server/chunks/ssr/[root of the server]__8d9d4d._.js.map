{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/app/_components/modes.tsx/proxy.js"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const Modes = registerClientReference(\n    function() { throw new Error(\"Attempted to call Modes() from the server but Modes is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/_components/modes.tsx <module evaluation>\",\n    \"Modes\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,QAAQ,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACvC;IAAa,MAAM,IAAI,MAAM;AAA0N,GACvP,+DACA"}},
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/app/_components/modes.tsx/proxy.js"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const Modes = registerClientReference(\n    function() { throw new Error(\"Attempted to call Modes() from the server but Modes is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/_components/modes.tsx\",\n    \"Modes\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,QAAQ,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACvC;IAAa,MAAM,IAAI,MAAM;AAA0N,GACvP,2CACA"}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 35, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 53, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/env.js"],"sourcesContent":["import { createEnv } from \"@t3-oss/env-nextjs\";\nimport { z } from \"zod\";\n\nexport const env = createEnv({\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars.\n   */\n  server: {\n    DATABASE_URL: z.string().url(),\n    NODE_ENV: z\n      .enum([\"development\", \"test\", \"production\"])\n      .default(\"development\"),\n  },\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars. To expose them to the client, prefix them with\n   * `NEXT_PUBLIC_`.\n   */\n  client: {\n    // NEXT_PUBLIC_CLIENTVAR: z.string(),\n  },\n\n  /**\n   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.\n   * middlewares) or client-side so we need to destruct manually.\n   */\n  runtimeEnv: {\n    DATABASE_URL: process.env.DATABASE_URL,\n    NODE_ENV: process.env.NODE_ENV,\n    // NEXT_PUBLIC_CLIENTVAR: process.env.NEXT_PUBLIC_CLIENTVAR,\n  },\n  /**\n   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially\n   * useful for Docker builds.\n   */\n  skipValidation: !!process.env.SKIP_ENV_VALIDATION,\n  /**\n   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and\n   * `SOME_VAR=''` will throw an error.\n   */\n  emptyStringAsUndefined: true,\n});\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,MAAM,MAAM,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD,EAAE;IAC3B;;;GAGC,GACD,QAAQ;QACN,cAAc,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG;QAC5B,UAAU,oIAAA,CAAA,IAAC,CACR,IAAI,CAAC;YAAC;YAAe;YAAQ;SAAa,EAC1C,OAAO,CAAC;IACb;IAEA;;;;GAIC,GACD,QAAQ;IAER;IAEA;;;GAGC,GACD,YAAY;QACV,cAAc,QAAQ,GAAG,CAAC,YAAY;QACtC,QAAQ;IAEV;IACA;;;GAGC,GACD,gBAAgB,CAAC,CAAC,QAAQ,GAAG,CAAC,mBAAmB;IACjD;;;GAGC,GACD,wBAAwB;AAC1B"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/server/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nimport { env } from \"~/env\";\n\nconst createPrismaClient = () =>\n  new PrismaClient({\n    log:\n      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: ReturnType<typeof createPrismaClient> | undefined;\n};\n\nexport const db = globalForPrisma.prisma ?? createPrismaClient();\n\nif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = db;\n"],"names":[],"mappings":";;;AAAA;AAEA;;;AAEA,MAAM,qBAAqB,IACzB,IAAI,2GAAA,CAAA,eAAY,CAAC;QACf,KACE,0GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,gBAAgB;YAAC;YAAS;YAAS;SAAO,GAAG;YAAC;SAAQ;IAC3E;AAEF,MAAM,kBAAkB;AAIjB,MAAM,KAAK,gBAAgB,MAAM,IAAI;AAE5C,IAAI,0GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,cAAc,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 119, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/server/api/trpc.ts"],"sourcesContent":["/**\n * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n * 1. You want to modify request context (see Part 1).\n * 2. You want to create a new middleware or type of procedure (see Part 3).\n *\n * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n * need to use are documented accordingly near the end.\n */\nimport { initTRPC } from \"@trpc/server\";\nimport superjson from \"superjson\";\nimport { ZodError } from \"zod\";\n\nimport { db } from \"~/server/db\";\n\n/**\n * 1. CONTEXT\n *\n * This section defines the \"contexts\" that are available in the backend API.\n *\n * These allow you to access things when processing a request, like the database, the session, etc.\n *\n * This helper generates the \"internals\" for a tRPC context. The API handler and RSC clients each\n * wrap this and provides the required context.\n *\n * @see https://trpc.io/docs/server/context\n */\nexport const createTRPCContext = async (opts: { headers: Headers }) => {\n  return {\n    db,\n    ...opts,\n  };\n};\n\n/**\n * 2. INITIALIZATION\n *\n * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\n * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\n * errors on the backend.\n */\nconst t = initTRPC.context<typeof createTRPCContext>().create({\n  transformer: superjson,\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\n/**\n * Create a server-side caller.\n *\n * @see https://trpc.io/docs/server/server-side-calls\n */\nexport const createCallerFactory = t.createCallerFactory;\n\n/**\n * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n *\n * These are the pieces you use to build your tRPC API. You should import these a lot in the\n * \"/src/server/api/routers\" directory.\n */\n\n/**\n * This is how you create new routers and sub-routers in your tRPC API.\n *\n * @see https://trpc.io/docs/router\n */\nexport const createTRPCRouter = t.router;\n\n/**\n * Middleware for timing procedure execution and adding an artificial delay in development.\n *\n * You can remove this if you don't like it, but it can help catch unwanted waterfalls by simulating\n * network latency that would occur in production but not in local development.\n */\nconst timingMiddleware = t.middleware(async ({ next, path }) => {\n  const start = Date.now();\n\n  if (t._config.isDev) {\n    // artificial delay in dev\n    const waitMs = Math.floor(Math.random() * 400) + 100;\n    await new Promise((resolve) => setTimeout(resolve, waitMs));\n  }\n\n  const result = await next();\n\n  const end = Date.now();\n  console.log(`[TRPC] ${path} took ${end - start}ms to execute`);\n\n  return result;\n});\n\n/**\n * Public (unauthenticated) procedure\n *\n * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n * guarantee that a user querying is authorized, but you can still access user session data if they\n * are logged in.\n */\nexport const publicProcedure = t.procedure.use(timingMiddleware);\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;;;;AACD;AACA;AAGA;AAJA;AAEA;;;;;AAgBO,MAAM,oBAAoB,OAAO;IACtC,OAAO;QACL,IAAA,mHAAA,CAAA,KAAE;QACF,GAAG,IAAI;IACT;AACF;AAEA;;;;;;CAMC,GACD,MAAM,IAAI,gMAAA,CAAA,WAAQ,CAAC,OAAO,GAA6B,MAAM,CAAC;IAC5D,aAAa,0IAAA,CAAA,UAAS;IACtB,gBAAe,EAAE,KAAK,EAAE,KAAK,EAAE;QAC7B,OAAO;YACL,GAAG,KAAK;YACR,MAAM;gBACJ,GAAG,MAAM,IAAI;gBACb,UACE,MAAM,KAAK,YAAY,oIAAA,CAAA,WAAQ,GAAG,MAAM,KAAK,CAAC,OAAO,KAAK;YAC9D;QACF;IACF;AACF;AAOO,MAAM,sBAAsB,EAAE,mBAAmB;AAcjD,MAAM,mBAAmB,EAAE,MAAM;AAExC;;;;;CAKC,GACD,MAAM,mBAAmB,EAAE,UAAU,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE;IACzD,MAAM,QAAQ,KAAK,GAAG;IAEtB,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE;QACnB,0BAA0B;QAC1B,MAAM,SAAS,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,OAAO;QACjD,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS;IACrD;IAEA,MAAM,SAAS,MAAM;IAErB,MAAM,MAAM,KAAK,GAAG;IACpB,QAAQ,GAAG,CAAC,CAAC,OAAO,EAAE,KAAK,MAAM,EAAE,MAAM,MAAM,aAAa,CAAC;IAE7D,OAAO;AACT;AASO,MAAM,kBAAkB,EAAE,SAAS,CAAC,GAAG,CAAC"}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 197, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/server/api/routers/song.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nimport { z } from \"zod\";\n\nimport { createTRPCRouter, publicProcedure } from \"~/server/api/trpc\";\n\nconst prisma = new PrismaClient();\n\nexport const songRouter = createTRPCRouter({\n  getSongToGuess: publicProcedure\n  .input(\n    z.object({\n      userId: z.string(),\n      modeId: z.number(),\n    })\n  ).query(async ({ input }) => {\n    console.log('Validated input:', input); // Zod validates the input here\n    console.log(\"coucou2\")\n\n    // // Check if the mode exists in the mode table\n    // const mode = await prisma.mode.findUnique({\n    //   where: { id: modeId },\n    // });\n\n    // if (!mode) {\n    //   throw new Error('Invalid mode');\n    // }\n    // return mode;\n\n    // // Check if the user exists\n    // let user = await prisma.user.findUnique({\n    //   where: { anonymousUserId: userId },\n    // });\n\n    // // If the user doesn't exist, create a new one\n    // if (!user) {\n    //   user = await prisma.user.create({\n    //     data: {\n    //       anonymousUserId: userId,\n    //     },\n    //   });\n    // }\n\n    // // Get today's date range\n    // const today = new Date();\n    // const startOfDay = new Date(today.setHours(0, 0, 0, 0));\n    // const endOfDay = new Date(today.setHours(23, 59, 59, 999));\n\n    // // Check if there's already an entry in the \"day\" table for today\n    // let dayEntry = await prisma.day.findFirst({\n    //   where: {\n    //     date: {\n    //       gte: startOfDay,\n    //       lte: endOfDay,\n    //     },\n    //   },\n    // });\n\n    // // If no entry exists, create a new one for today\n    // if (!dayEntry) {\n    //   dayEntry = await prisma.day.create({\n    //     data: {\n    //       date: new Date(),\n    //       seed: getRandom64BitNumber(),\n    //     },\n    //   });\n    // }\n\n    // // Count successful guesses for today\n    // let todaysUserGuesses = await prisma.guess.count({\n    //   where: {\n    //     userId: user.id,\n    //     date: {\n    //       gte: startOfDay,\n    //       lte: endOfDay,\n    //     },\n    //   },\n    // });\n\n    // // Get Spotify song IDs from the playlist\n    // const songsIDs = await getSpotifyPlaylistTracks(mode.playlistId);\n    // const todaysIndexSequence = ShuffleIndexes(dayEntry.seed, songsIDs.length);\n    // const songToGuessSpotifyId = songsIDs[todaysIndexSequence[todaysUserGuesses] ?? 0];\n\n    // // Compare the song to guess with the provided song ID\n    // const detailedComparison = await compareSongs(songToGuessSpotifyId, songSpotifyId);\n\n    // // Store the guess in the database\n    // const guess = await prisma.guess.create({\n    //   data: {\n    //     userId: user.id,\n    //     date: new Date(),\n    //     modeId: mode.id,\n    //     songSpotifyId: songSpotifyId,\n    //     success: songToGuessSpotifyId === songSpotifyId,\n    //     diff: detailedComparison,\n    //   },\n    // });\n\n    // return guess;\n  }),\n});\n"],"names":[],"mappings":";;;AAAA;AAGA;AAFA;;;;AAIA,MAAM,SAAS,IAAI,2GAAA,CAAA,eAAY;AAExB,MAAM,aAAa,CAAA,GAAA,4HAAA,CAAA,mBAAgB,AAAD,EAAE;IACzC,gBAAgB,4HAAA,CAAA,kBAAe,CAC9B,KAAK,CACJ,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACP,QAAQ,oIAAA,CAAA,IAAC,CAAC,MAAM;QAChB,QAAQ,oIAAA,CAAA,IAAC,CAAC,MAAM;IAClB,IACA,KAAK,CAAC,OAAO,EAAE,KAAK,EAAE;QACtB,QAAQ,GAAG,CAAC,oBAAoB,QAAQ,+BAA+B;QACvE,QAAQ,GAAG,CAAC;IAEZ,gDAAgD;IAChD,8CAA8C;IAC9C,2BAA2B;IAC3B,MAAM;IAEN,eAAe;IACf,qCAAqC;IACrC,IAAI;IACJ,eAAe;IAEf,8BAA8B;IAC9B,4CAA4C;IAC5C,wCAAwC;IACxC,MAAM;IAEN,iDAAiD;IACjD,eAAe;IACf,sCAAsC;IACtC,cAAc;IACd,iCAAiC;IACjC,SAAS;IACT,QAAQ;IACR,IAAI;IAEJ,4BAA4B;IAC5B,4BAA4B;IAC5B,2DAA2D;IAC3D,8DAA8D;IAE9D,oEAAoE;IACpE,8CAA8C;IAC9C,aAAa;IACb,cAAc;IACd,yBAAyB;IACzB,uBAAuB;IACvB,SAAS;IACT,OAAO;IACP,MAAM;IAEN,oDAAoD;IACpD,mBAAmB;IACnB,yCAAyC;IACzC,cAAc;IACd,0BAA0B;IAC1B,sCAAsC;IACtC,SAAS;IACT,QAAQ;IACR,IAAI;IAEJ,wCAAwC;IACxC,qDAAqD;IACrD,aAAa;IACb,uBAAuB;IACvB,cAAc;IACd,yBAAyB;IACzB,uBAAuB;IACvB,SAAS;IACT,OAAO;IACP,MAAM;IAEN,4CAA4C;IAC5C,oEAAoE;IACpE,8EAA8E;IAC9E,sFAAsF;IAEtF,yDAAyD;IACzD,sFAAsF;IAEtF,qCAAqC;IACrC,4CAA4C;IAC5C,YAAY;IACZ,uBAAuB;IACvB,wBAAwB;IACxB,uBAAuB;IACvB,oCAAoC;IACpC,uDAAuD;IACvD,gCAAgC;IAChC,OAAO;IACP,MAAM;IAEN,gBAAgB;IAClB;AACF"}},
    {"offset": {"line": 286, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 292, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/server/api/routers/modes.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nimport { randomInt } from \"crypto\";\nimport { create } from \"domain\";\nimport { z } from \"zod\";\n\nimport { createTRPCRouter, publicProcedure } from \"~/server/api/trpc\";\n\nconst prisma = new PrismaClient();\n\nexport const modeRouter = createTRPCRouter({\n  getModes: publicProcedure\n  .query(async () => {\n    return await prisma.mode.findMany();\n  }),\n  createMode: publicProcedure\n  .input(\n    z.object({\n      playlistId: z.string(),\n    })\n  ).mutation(async ({ input }) => {\n    console.log('Validated input:', input); // Zod validates the input here\n\n    const { playlistId } = input;\n\n    const mode = await prisma.mode.create({\n      data: {\n        playlistId: playlistId,\n        name: \"New mode\",\n      },\n    });\n\n    return mode;\n  })\n});\n"],"names":[],"mappings":";;;AAAA;AAKA;AAFA;;;;AAIA,MAAM,SAAS,IAAI,2GAAA,CAAA,eAAY;AAExB,MAAM,aAAa,CAAA,GAAA,4HAAA,CAAA,mBAAgB,AAAD,EAAE;IACzC,UAAU,4HAAA,CAAA,kBAAe,CACxB,KAAK,CAAC;QACL,OAAO,MAAM,OAAO,IAAI,CAAC,QAAQ;IACnC;IACA,YAAY,4HAAA,CAAA,kBAAe,CAC1B,KAAK,CACJ,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACP,YAAY,oIAAA,CAAA,IAAC,CAAC,MAAM;IACtB,IACA,QAAQ,CAAC,OAAO,EAAE,KAAK,EAAE;QACzB,QAAQ,GAAG,CAAC,oBAAoB,QAAQ,+BAA+B;QAEvE,MAAM,EAAE,UAAU,EAAE,GAAG;QAEvB,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,MAAM,CAAC;YACpC,MAAM;gBACJ,YAAY;gBACZ,MAAM;YACR;QACF;QAEA,OAAO;IACT;AACF"}},
    {"offset": {"line": 320, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 326, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/server/api/root.ts"],"sourcesContent":["import { postRouter } from \"~/server/api/routers/post\";\nimport { createCallerFactory, createTRPCRouter } from \"~/server/api/trpc\";\nimport { songRouter } from \"./routers/song\";\nimport { modeRouter } from \"./routers/modes\";\n\n/**\n * This is the primary router for your server.\n *\n * All routers added in /api/routers should be manually added here.\n */\nexport const appRouter = createTRPCRouter({\n  mode: modeRouter,\n  song: songRouter\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n\n/**\n * Create a server-side caller for the tRPC API.\n * @example\n * const trpc = createCaller(createContext);\n * const res = await trpc.post.all();\n *       ^? Post[]\n */\nexport const createCaller = createCallerFactory(appRouter);\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAOO,MAAM,YAAY,CAAA,GAAA,4HAAA,CAAA,mBAAgB,AAAD,EAAE;IACxC,MAAM,wIAAA,CAAA,aAAU;IAChB,MAAM,uIAAA,CAAA,aAAU;AAClB;AAYO,MAAM,eAAe,CAAA,GAAA,4HAAA,CAAA,sBAAmB,AAAD,EAAE"}},
    {"offset": {"line": 341, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 347, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/trpc/query-client.ts"],"sourcesContent":["import {\n  defaultShouldDehydrateQuery,\n  QueryClient,\n} from \"@tanstack/react-query\";\nimport SuperJSON from \"superjson\";\n\nexport const createQueryClient = () =>\n  new QueryClient({\n    defaultOptions: {\n      queries: {\n        // With SSR, we usually want to set some default staleTime\n        // above 0 to avoid refetching immediately on the client\n        staleTime: 30 * 1000,\n      },\n      dehydrate: {\n        serializeData: SuperJSON.serialize,\n        shouldDehydrateQuery: (query) =>\n          defaultShouldDehydrateQuery(query) ||\n          query.state.status === \"pending\",\n      },\n      hydrate: {\n        deserializeData: SuperJSON.deserialize,\n      },\n    },\n  });\n"],"names":[],"mappings":";;;AAIA;AAJA;AAAA;;;AAMO,MAAM,oBAAoB,IAC/B,IAAI,6KAAA,CAAA,cAAW,CAAC;QACd,gBAAgB;YACd,SAAS;gBACP,0DAA0D;gBAC1D,wDAAwD;gBACxD,WAAW,KAAK;YAClB;YACA,WAAW;gBACT,eAAe,0IAAA,CAAA,UAAS,CAAC,SAAS;gBAClC,sBAAsB,CAAC,QACrB,CAAA,GAAA,2KAAA,CAAA,8BAA2B,AAAD,EAAE,UAC5B,MAAM,KAAK,CAAC,MAAM,KAAK;YAC3B;YACA,SAAS;gBACP,iBAAiB,0IAAA,CAAA,UAAS,CAAC,WAAW;YACxC;QACF;IACF"}},
    {"offset": {"line": 371, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 377, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/trpc/server.ts"],"sourcesContent":["import \"server-only\";\n\nimport { createHydrationHelpers } from \"@trpc/react-query/rsc\";\nimport { headers } from \"next/headers\";\nimport { cache } from \"react\";\n\nimport { createCaller, type AppRouter } from \"~/server/api/root\";\nimport { createTRPCContext } from \"~/server/api/trpc\";\nimport { createQueryClient } from \"./query-client\";\n\n/**\n * This wraps the `createTRPCContext` helper and provides the required context for the tRPC API when\n * handling a tRPC call from a React Server Component.\n */\nconst createContext = cache(() => {\n  const heads = new Headers(headers());\n  heads.set(\"x-trpc-source\", \"rsc\");\n\n  return createTRPCContext({\n    headers: heads,\n  });\n});\n\nconst getQueryClient = cache(createQueryClient);\nconst caller = createCaller(createContext);\n\nexport const { trpc: api, HydrateClient } = createHydrationHelpers<AppRouter>(\n  caller,\n  getQueryClient\n);\n"],"names":[],"mappings":";;;;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;AAEA;;;CAGC,GACD,MAAM,gBAAgB,CAAA,GAAA,qMAAA,CAAA,QAAK,AAAD,EAAE;IAC1B,MAAM,QAAQ,IAAI,QAAQ,CAAA,GAAA,+HAAA,CAAA,UAAO,AAAD;IAChC,MAAM,GAAG,CAAC,iBAAiB;IAE3B,OAAO,CAAA,GAAA,4HAAA,CAAA,oBAAiB,AAAD,EAAE;QACvB,SAAS;IACX;AACF;AAEA,MAAM,iBAAiB,CAAA,GAAA,qMAAA,CAAA,QAAK,AAAD,EAAE,8HAAA,CAAA,oBAAiB;AAC9C,MAAM,SAAS,CAAA,GAAA,4HAAA,CAAA,eAAY,AAAD,EAAE;AAErB,MAAM,EAAE,MAAM,GAAG,EAAE,aAAa,EAAE,GAAG,CAAA,GAAA,wJAAA,CAAA,yBAAsB,AAAD,EAC/D,QACA"}},
    {"offset": {"line": 408, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 414, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/app/page.tsx"],"sourcesContent":["import { api, HydrateClient } from \"~/trpc/server\";\n\nexport default async function Home() {\n  // const hello = await api.post.hello({ text: \"from tRPC\" });\n\n  void api.mode.getModes.prefetch();\n\n  return (\n    <HydrateClient>\n      <main className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c] text-white\">\n        <div className=\"container flex flex-col items-center justify-center gap-12 px-4 py-16\">\n          <div className=\"flex flex-col items-center gap-2\">\n          </div>\n        </div>\n      </main>\n    </HydrateClient>\n  );\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAEe,eAAe;IAC5B,6DAA6D;IAE7D,KAAK,qHAAA,CAAA,MAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ;IAE/B,qBACE,8OAAC,qHAAA,CAAA,gBAAa;kBACZ,cAAA,8OAAC;YAAK,WAAU;sBACd,cAAA,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC;oBAAI,WAAU;;;;;;;;;;;;;;;;;;;;;AAMzB"}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 464, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 465, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}
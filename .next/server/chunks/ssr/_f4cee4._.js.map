{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/src/app/_components/songs.tsx"],"sourcesContent":["\"use client\";\n\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { useState } from \"react\";\nimport { api } from \"~/trpc/react\";\n\nexport function Songs() {\n  const queryClient = useQueryClient(); // Initialize the query client\n\n  // State for form input\n  const [chosenModeId, setChosenModeId] = useState(\"\");\n  const [userAnonymousId, setUserAnonymousId] = useState(\"\");\n\n  // Query to get the song, based on input\n  const { data: songToGuess, error, isFetching } = api.song.getSongToGuess.useQuery(\n    {\n      anonymousUserId: userAnonymousId,\n      modeId: parseInt(chosenModeId) || 0, // Convert to number or fallback to 0\n    },\n    {\n      enabled: !!userAnonymousId && !!chosenModeId, // Only fetch if input is valid\n    }\n  );\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n  };\n\n  return (\n    <div className=\"w-full max-w-xs\">\n      {isFetching ? (\n        <p>Loading song...</p>\n      ) : error ? (\n        <p>Error fetching song: {error.message}</p>\n      ) : songToGuess ? (\n        <p className=\"truncate\">\n          Chosen mode: name = {songToGuess.mode.name}, playlistId = {songToGuess.mode.playlistId}\n          <br />\n          Today's date: {new Date(songToGuess.dayEntry.date).toLocaleDateString()}\n          <br />\n          Today's seed: {songToGuess.dayEntry.seed}\n        </p>\n      ) : (\n        <p>No song to guess</p>\n      )}\n\n      <form onSubmit={handleSubmit} className=\"flex flex-col gap-2\">\n        <input\n          type=\"integer\"\n          placeholder=\"Mode ID\"\n          value={chosenModeId}\n          onChange={(e) => setChosenModeId(e.target.value)}\n          className=\"w-full rounded-full px-4 py-2 text-black\"\n        />\n        <input\n          type=\"text\"\n          placeholder=\"User Anonymous ID\"\n          value={userAnonymousId}\n          onChange={(e) => setUserAnonymousId(e.target.value)}\n          className=\"w-full rounded-full px-4 py-2 text-black\"\n        />\n        <button\n          type=\"submit\"\n          className=\"rounded-full bg-white/10 px-10 py-3 font-semibold transition hover:bg-white/20\"\n          disabled={isFetching}\n        >\n          {isFetching ? \"Submitting...\" : \"Submit\"}\n        </button>\n      </form>\n    </div>\n  );\n}"],"names":[],"mappings":";;;;AAGA;AACA;AAFA;AAFA;;;;;AAMO,SAAS;IACd,MAAM,cAAc,CAAA,GAAA,sLAAA,CAAA,iBAAc,AAAD,KAAK,8BAA8B;IAEpE,uBAAuB;IACvB,MAAM,CAAC,cAAc,gBAAgB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IACjD,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAEvD,wCAAwC;IACxC,MAAM,EAAE,MAAM,WAAW,EAAE,KAAK,EAAE,UAAU,EAAE,GAAG,qHAAA,CAAA,MAAG,CAAC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAC/E;QACE,iBAAiB;QACjB,QAAQ,SAAS,iBAAiB;IACpC,GACA;QACE,SAAS,CAAC,CAAC,mBAAmB,CAAC,CAAC;IAClC;IAGF,MAAM,eAAe,CAAC;QACpB,EAAE,cAAc;IAClB;IAEA,qBACE,8OAAC;QAAI,WAAU;;YACZ,2BACC,8OAAC;0BAAE;;;;;uBACD,sBACF,8OAAC;;oBAAE;oBAAsB,MAAM,OAAO;;;;;;uBACpC,4BACF,8OAAC;gBAAE,WAAU;;oBAAW;oBACD,YAAY,IAAI,CAAC,IAAI;oBAAC;oBAAgB,YAAY,IAAI,CAAC,UAAU;kCACtF,8OAAC;;;;;oBAAK;oBACS,IAAI,KAAK,YAAY,QAAQ,CAAC,IAAI,EAAE,kBAAkB;kCACrE,8OAAC;;;;;oBAAK;oBACS,YAAY,QAAQ,CAAC,IAAI;;;;;;qCAG1C,8OAAC;0BAAE;;;;;;0BAGL,8OAAC;gBAAK,UAAU;gBAAc,WAAU;;kCACtC,8OAAC;wBACC,MAAK;wBACL,aAAY;wBACZ,OAAO;wBACP,UAAU,CAAC,IAAM,gBAAgB,EAAE,MAAM,CAAC,KAAK;wBAC/C,WAAU;;;;;;kCAEZ,8OAAC;wBACC,MAAK;wBACL,aAAY;wBACZ,OAAO;wBACP,UAAU,CAAC,IAAM,mBAAmB,EAAE,MAAM,CAAC,KAAK;wBAClD,WAAU;;;;;;kCAEZ,8OAAC;wBACC,MAAK;wBACL,WAAU;wBACV,UAAU;kCAET,aAAa,kBAAkB;;;;;;;;;;;;;;;;;;AAK1C"}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 145, "column": 0}, "map": {"version":3,"sources":["file:///home/berry/Development/song-of-the-day/node_modules/%40tanstack/react-query/src/HydrationBoundary.tsx"],"sourcesContent":["/* eslint-disable react-compiler/react-compiler */\n\n'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DehydratedState,\n  HydrateOptions,\n  OmitKeyof,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport interface HydrationBoundaryProps {\n  state?: unknown\n  options?: OmitKeyof<HydrateOptions, 'defaultOptions'> & {\n    defaultOptions?: OmitKeyof<\n      Exclude<HydrateOptions['defaultOptions'], undefined>,\n      'mutations'\n    >\n  }\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n  const [hydrationQueue, setHydrationQueue] = React.useState<\n    DehydratedState['queries'] | undefined\n  >()\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // This useMemo is for performance reasons only, everything inside it _must_\n  // be safe to run in every render and code here should be read as \"in render\".\n  //\n  // This code needs to happen during the render phase, because after initial\n  // SSR, hydration needs to happen _before_ children render. Also, if hydrating\n  // during a transition, we want to hydrate as much as is safe in render so\n  // we can prerender as much as possible.\n  //\n  // For any queries that already exist in the cache, we want to hold back on\n  // hydrating until _after_ the render phase. The reason for this is that during\n  // transitions, we don't want the existing queries and observers to update to\n  // the new data on the current page, only _after_ the transition is committed.\n  // If the transition is aborted, we will have hydrated any _new_ queries, but\n  // we throw away the fresh data for any existing ones to avoid unexpectedly\n  // updating the UI.\n  React.useMemo(() => {\n    if (state) {\n      if (typeof state !== 'object') {\n        return\n      }\n\n      const queryCache = client.getQueryCache()\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      const queries = (state as DehydratedState).queries || []\n\n      const newQueries: DehydratedState['queries'] = []\n      const existingQueries: DehydratedState['queries'] = []\n      for (const dehydratedQuery of queries) {\n        const existingQuery = queryCache.get(dehydratedQuery.queryHash)\n\n        if (!existingQuery) {\n          newQueries.push(dehydratedQuery)\n        } else {\n          const hydrationIsNewer =\n            dehydratedQuery.state.dataUpdatedAt >\n            existingQuery.state.dataUpdatedAt\n          const queryAlreadyQueued = hydrationQueue?.find(\n            (query) => query.queryHash === dehydratedQuery.queryHash,\n          )\n\n          if (\n            hydrationIsNewer &&\n            (!queryAlreadyQueued ||\n              dehydratedQuery.state.dataUpdatedAt >\n                queryAlreadyQueued.state.dataUpdatedAt)\n          ) {\n            existingQueries.push(dehydratedQuery)\n          }\n        }\n      }\n\n      if (newQueries.length > 0) {\n        // It's actually fine to call this with queries/state that already exists\n        // in the cache, or is older. hydrate() is idempotent for queries.\n        hydrate(client, { queries: newQueries }, optionsRef.current)\n      }\n      if (existingQueries.length > 0) {\n        setHydrationQueue((prev) =>\n          prev ? [...prev, ...existingQueries] : existingQueries,\n        )\n      }\n    }\n  }, [client, hydrationQueue, state])\n\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current)\n      setHydrationQueue(undefined)\n    }\n  }, [client, hydrationQueue])\n\n  return children as React.ReactElement\n}\n"],"names":[],"mappings":";;;;AAGA,YAAY,WAAW;AAGvB,SAAS,sBAAsB;AAD/B,SAAS,eAAe;;;;;AAqBjB,IAAM,oBAAoB,CAAC,EAChC,QAAA,EACA,UAAU,CAAC,CAAA,EACX,KAAA,EACA,WAAA,EACF,KAA8B;IAC5B,MAAM,mMAAS,kBAAA,EAAe,WAAW;IACzC,MAAM,CAAC,gBAAgB,iBAAiB,CAAA,GAAU,sMAAA,QAAA,CAEhD;IAEF,MAAM,aAAmB,sMAAA,MAAA,CAAO,OAAO;IACvC,WAAW,OAAA,GAAU;IAiBf,sMAAA,OAAA,CAAQ,MAAM;QAClB,IAAI,OAAO;YACT,IAAI,OAAO,UAAU,UAAU;gBAC7B;YACF;YAEA,MAAM,aAAa,OAAO,aAAA,CAAc;YAExC,MAAM,UAAW,MAA0B,OAAA,IAAW,CAAC,CAAA;YAEvD,MAAM,aAAyC,CAAC,CAAA;YAChD,MAAM,kBAA8C,CAAC,CAAA;YACrD,KAAA,MAAW,mBAAmB,QAAS;gBACrC,MAAM,gBAAgB,WAAW,GAAA,CAAI,gBAAgB,SAAS;gBAE9D,IAAI,CAAC,eAAe;oBAClB,WAAW,IAAA,CAAK,eAAe;gBACjC,OAAO;oBACL,MAAM,mBACJ,gBAAgB,KAAA,CAAM,aAAA,GACtB,cAAc,KAAA,CAAM,aAAA;oBACtB,MAAM,qBAAqB,gBAAgB,KACzC,CAAC,QAAU,MAAM,SAAA,KAAc,gBAAgB,SAAA;oBAGjD,IACE,oBAAA,CACC,CAAC,sBACA,gBAAgB,KAAA,CAAM,aAAA,GACpB,mBAAmB,KAAA,CAAM,aAAA,GAC7B;wBACA,gBAAgB,IAAA,CAAK,eAAe;oBACtC;gBACF;YACF;YAEA,IAAI,WAAW,MAAA,GAAS,GAAG;gBAGzB,CAAA,GAAA,2KAAA,CAAA,UAAA,EAAQ,QAAQ;oBAAE,SAAS;gBAAW,GAAG,WAAW,OAAO;YAC7D;YACA,IAAI,gBAAgB,MAAA,GAAS,GAAG;gBAC9B,kBAAkB,CAAC,OACjB,OAAO,CAAC;2BAAG,MAAM;2BAAG,eAAe;qBAAA,GAAI;YAE3C;QACF;IACF,GAAG;QAAC;QAAQ;QAAgB,KAAK;KAAC;IAE5B,sMAAA,SAAA,CAAU,MAAM;QACpB,IAAI,gBAAgB;YAClB,CAAA,GAAA,2KAAA,CAAA,UAAA,EAAQ,QAAQ;gBAAE,SAAS;YAAe,GAAG,WAAW,OAAO;YAC/D,kBAAkB,KAAA,CAAS;QAC7B;IACF,GAAG;QAAC;QAAQ,cAAc;KAAC;IAE3B,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}